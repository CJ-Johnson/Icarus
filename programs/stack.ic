// Implementation of a stack with a linked list
node := struct {
  _data: int
  _next: &node
}

stack := struct {
  _size: uint
  _head: &node
}

size  := (this: &stack) -> uint { return this._size }
empty := (this: &stack) -> bool { return this._size == 0u }

push := (this: &stack, n: int) -> &stack {
  new: &node
  allocate(&new)
  // new.allocate()

  new._data = n
  new._next = this._head
  this._head = new
  this._size += 1u
  return this
}

// Unsafe if stack is empty. This is a good place to use #ensure to enforce a
// check at the call-size that the stack is non-empty
peek := (this: &stack) -> int {
  // Alternatively, we can use a check like this, but this is worse, because the
  // callee has no way to know the correct behavior in the context. It's also
  // indistinguishable from correct behavior where the top of the stack has the
  // default value.
  return case {
    !this.empty() => this._head._data
    else          => 0
  }
}

pop := (this: &stack) -> &stack {
  x: &node
  if this._head != x {
    old := this._head
    this._head = this._head._next
    free old
    this._size -= 1u
  }
  return this
}

__destroy__ := (s: &stack) -> void {
  while !s.empty() { s.pop() }
}

main := void -> void {
  __print__ := (s: stack) -> void {
    next := s._head
    x: &node

    while next != x {
      print next._data, " -> "
      next = next._next
    }
  }

  st: stack
  print @st.push(1).push(2).push(3).pop().pop().push(7)
}

Any := (T: type) -> bool {
  return true
}

allocate := (ptr: &&Any`T) -> void {
  malloc: uint -> &char #cstdlib
  @ptr = malloc(T.bytes) :> &T
}


