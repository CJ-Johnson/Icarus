// Implementation of a stack with a linked list
node := struct (T: type) {
  _data: T
  _next: &node(T)
}

stack := struct (T: type) {
  _size: uint
  _head: &node(T)
}

size  := (this: &stack(Any`T)) -> uint { return this._size }
empty := (this: &stack(Any`T)) -> bool { return this._size == 0u }

push := (this: &stack(Any`T), n: T) -> &stack(T) {
  new: &node(T)
  allocate(&new)

  new._data = n
  new._next = this._head
  this._head = new
  this._size += 1u
  return this
}

// Unsafe if stack is empty. This is a good place to use #ensure to enforce a
// check at the call-size that the stack is non-empty
peek := (this: &stack(Any`T)) -> int {
  // Alternatively, we can use a check like this, but this is worse, because the
  // callee has no way to know the correct behavior in the context. It's also
  // indistinguishable from correct behavior where the top of the stack has the
  // default value.
  return case {
    !this.empty() => this._head._data
    else          => 0
  }
}

pop := (this: &stack(Any`T)) -> &stack(T) {
  x: &node(T)
  if this._head != x {
    old := this._head
    this._head = this._head._next
    free old
    this._size -= 1u
  }
  return this
}

__destroy__ := (s: &stack(Any`T)) -> void {
  ptrptr := &s._head._next
  nullptr: &node(T)

  while @ptrptr != nullptr {
    to_free := @ptrptr
    ptrptr = &ptrptr._next
    free to_free
  }
}

main := void -> void {
  __print__ := (s: stack(int)) -> void {
    if s.empty() {
      print "{}"
      return
    }

    print "{ ", s._head._data

    current := s._head._next
    x: &node(int)

    while current != x {
      print " -> ", current._data
      current = current._next
    }

    print " }"
  }

  st: stack(int)
  print @st.push(1).push(2).push(3).pop().pop().push(7)
}

Any := (T: type) -> bool { return true }

allocate := (ptr: &&Any`T) -> void {
  malloc: uint -> &char #cstdlib
  @ptr = malloc(T.bytes) :> &T
}
