src/AST/AST.h:210:    return init_val && !init_val->is_hole();
src/AST/AST.h:213:    return init_val && init_val->is_hole();
src/AST/AST.h:281:    for (auto &stmt : stmts->statements) {
src/AST/AST.h:384:  // non-zero) and also for error generation (if multiple else-blocks are
src/AST/assign_scope.cpp:8:    ptr->assign_scope();                                                       \
src/AST/assign_scope.cpp:14:  operand->assign_scope();
src/AST/assign_scope.cpp:18:  operand->assign_scope();
src/AST/assign_scope.cpp:27:  length->assign_scope();
src/AST/assign_scope.cpp:28:  data_type->assign_scope();
src/AST/assign_scope.cpp:34:    body_scopes[i]->set_parent(CurrentScope());
src/AST/assign_scope.cpp:35:    conditions[i]->assign_scope();
src/AST/assign_scope.cpp:38:    statements[i]->assign_scope();
src/AST/assign_scope.cpp:43:    body_scopes.back()->set_parent(CurrentScope());
src/AST/assign_scope.cpp:45:    statements.back()->assign_scope();
src/AST/assign_scope.cpp:52:  for_scope->set_parent(CurrentScope());
src/AST/assign_scope.cpp:56:  for (auto iter : iterators) { iter->assign_scope(); }
src/AST/assign_scope.cpp:57:  statements->assign_scope();
src/AST/assign_scope.cpp:64:  while_scope->set_parent(CurrentScope());
src/AST/assign_scope.cpp:65:  condition->assign_scope();
src/AST/assign_scope.cpp:67:  statements->assign_scope();
src/AST/assign_scope.cpp:73:  for (auto &el : elems) { el->assign_scope(); }
src/AST/assign_scope.cpp:78:  lhs->assign_scope();
src/AST/assign_scope.cpp:79:  if (rhs) { rhs->assign_scope(); }
src/AST/assign_scope.cpp:86:  auto iter = scope_->ids_.find(identifier->token);
src/AST/assign_scope.cpp:87:  if (iter == scope_->ids_.end()) {
src/AST/assign_scope.cpp:88:    scope_->ids_[identifier->token] = identifier;
src/AST/assign_scope.cpp:92:  // scope_->ids_[identifier->token]->decls.push_back(this);
src/AST/assign_scope.cpp:94:  identifier->assign_scope();
src/AST/assign_scope.cpp:95:  test_fn->assign_scope();
src/AST/assign_scope.cpp:102:  auto iter = scope_->ids_.find(identifier->token);
src/AST/assign_scope.cpp:103:  if (iter == scope_->ids_.end()) {
src/AST/assign_scope.cpp:104:    scope_->ids_[identifier->token] = identifier;
src/AST/assign_scope.cpp:108:  // scope_->ids_[identifier->token]->decls.push_back(this);
src/AST/assign_scope.cpp:110:  identifier->assign_scope();
src/AST/assign_scope.cpp:111:  container->assign_scope();
src/AST/assign_scope.cpp:118:  auto iter = scope_->ids_.find(identifier->token);
src/AST/assign_scope.cpp:119:  if (iter == scope_->ids_.end()) {
src/AST/assign_scope.cpp:120:    scope_->ids_[identifier->token] = identifier;
src/AST/assign_scope.cpp:123:  scope_->DeclRegistry.push_back(this);
src/AST/assign_scope.cpp:124:  scope_->ids_[identifier->token]->decl = this;
src/AST/assign_scope.cpp:125:  identifier->assign_scope();
src/AST/assign_scope.cpp:126:  if (type_expr) { type_expr->assign_scope(); }
src/AST/assign_scope.cpp:127:  if (init_val) { init_val->assign_scope(); }
src/AST/assign_scope.cpp:132:  for (auto &expr : exprs) { expr->assign_scope(); }
src/AST/assign_scope.cpp:138:    kv.first->assign_scope();
src/AST/assign_scope.cpp:139:    kv.second->assign_scope();
src/AST/assign_scope.cpp:145:  for (auto &nptr : statements) { nptr->assign_scope(); }
src/AST/assign_scope.cpp:150:  fn_scope->set_parent(CurrentScope());
src/AST/assign_scope.cpp:152:  return_type_expr->assign_scope();
src/AST/assign_scope.cpp:153:  for (auto &in : inputs) { in->assign_scope(); }
src/AST/assign_scope.cpp:154:  statements->assign_scope();
src/AST/assign_scope.cpp:160:  type_scope->set_parent(CurrentScope());
src/AST/assign_scope.cpp:163:  for (auto p : params) { p->assign_scope(); }
src/AST/assign_scope.cpp:164:  for (auto d : decls) { d->assign_scope(); }
src/AST/assign_scope.cpp:170:  type_scope->set_parent(CurrentScope());
src/AST/assign_scope.cpp:173:  for (auto d : decls) { d->assign_scope(); }
src/AST/build.cpp:24:  if (expr->is_binop() &&
src/AST/build.cpp:25:      static_cast<AST::Binop *>(expr)->op == Language::Operator::Assign) {
src/AST/build.cpp:26:    error_log.log(expr->loc, msg + "Did you mean '==' instead of '='?");
src/AST/build.cpp:29:    static_cast<AST::Binop *>(expr)->op = Language::Operator::EQ;
src/AST/build.cpp:40:  binop_ptr->loc        = nodes[1]->loc;
src/AST/build.cpp:41:  binop_ptr->lhs        = steal<AST::Expression>(nodes[0]);
src/AST/build.cpp:42:  binop_ptr->rhs        = nullptr;
src/AST/build.cpp:43:  binop_ptr->op         = Language::Operator::Call;
src/AST/build.cpp:44:  binop_ptr->precedence = Language::precedence(binop_ptr->op);
src/AST/build.cpp:46:  if (binop_ptr->lhs->is_declaration()) {
src/AST/build.cpp:47:    error_log.log(binop_ptr->lhs->loc,
src/AST/build.cpp:63:  struct_lit_ptr->loc   = nodes[0]->loc;
src/AST/build.cpp:64:  struct_lit_ptr->type  = Type_;
src/AST/build.cpp:65:  struct_lit_ptr->value = Context::Value(Struct(
src/AST/build.cpp:67:  for (auto &&n : static_cast<Statements *>(nodes[2])->statements) {
src/AST/build.cpp:68:    if (n->is_declaration()) {
src/AST/build.cpp:69:      struct_lit_ptr->decls.push_back(steal<Declaration>(n));
src/AST/build.cpp:71:      error_log.log(n->loc,
src/AST/build.cpp:83:  struct_lit_ptr->loc   = nodes[0]->loc;
src/AST/build.cpp:84:  struct_lit_ptr->type  = Type_;
src/AST/build.cpp:85:  struct_lit_ptr->value = Context::Value(
src/AST/build.cpp:89:  if (nodes[1]->is_declaration()) {
src/AST/build.cpp:90:    struct_lit_ptr->params.push_back(steal<Declaration>(nodes[1]));
src/AST/build.cpp:92:  } else if (nodes[1]->is_comma_list()) {
src/AST/build.cpp:93:    auto expr_vec = steal<ChainOp>(nodes[1])->exprs;
src/AST/build.cpp:96:      struct_lit_ptr->params.push_back(steal<Declaration>(n));
src/AST/build.cpp:100:  for (auto &&node : static_cast<Statements *>(nodes[3])->statements) {
src/AST/build.cpp:101:    struct_lit_ptr->decls.push_back(steal<Declaration>(node));
src/AST/build.cpp:114:  enum_lit_ptr->loc  = nodes[0]->loc;
src/AST/build.cpp:115:  enum_lit_ptr->type = Type_;
src/AST/build.cpp:117:  if (nodes[2]->is_statements()) {
src/AST/build.cpp:119:    for (auto &&stmt : stmts->statements) {
src/AST/build.cpp:120:      if (!stmt->is_identifier()) {
src/AST/build.cpp:121:        error_log.log(stmt->loc, "Enum members must be identifiers.");
src/AST/build.cpp:125:        enum_lit_ptr->members.emplace_back(
src/AST/build.cpp:126:            static_cast<Identifier *>(stmt)->token);
src/AST/build.cpp:138:// Each statement is a binary operator using '=>'. The last one has a left-hand
src/AST/build.cpp:142:  case_ptr->loc = nodes[0]->loc;
src/AST/build.cpp:145:  auto num_stmts = stmts->statements.size();
src/AST/build.cpp:147:    auto stmt = stmts->statements[i];
src/AST/build.cpp:148:    if (!stmt->is_binop() ||
src/AST/build.cpp:149:        static_cast<Binop *>(stmt)->op != Language::Operator::Rocket) {
src/AST/build.cpp:150:      error_log.log(stmt->loc,
src/AST/build.cpp:151:                    "Each line in case statement must be a key-value pair.");
src/AST/build.cpp:158:    case_ptr->key_vals.emplace_back(steal<Expression>(binop->lhs),
src/AST/build.cpp:159:                                    steal<Expression>(binop->rhs));
src/AST/build.cpp:173:  if_stmt->conditions = {cond};
src/AST/build.cpp:175:                           "Expression in while-statement is an assignment. ");
src/AST/build.cpp:177:  if_stmt->statements = {steal<Statements>(nodes[3])};
src/AST/build.cpp:178:  if_stmt->body_scopes.push_back(new BlockScope(ScopeType::Conditional));
src/AST/build.cpp:189:  while_stmt->statements = steal<Statements>(nodes[3]);
src/AST/build.cpp:191:  while_stmt->condition = steal<Expression>(nodes[1]);
src/AST/build.cpp:192:  CheckEqualsNotAssignment(while_stmt->condition,
src/AST/build.cpp:193:                           "Condition in while-loop is an assignment. ");
src/AST/build.cpp:200:  if (!maybe_decl->is_in_decl()) {
src/AST/build.cpp:201:    error_log.log(maybe_decl->loc, "Expect 'in' declaration in for-loop.");
src/AST/build.cpp:211:// [expression] is either an in-declaration or a list of in-declarations
src/AST/build.cpp:214:  for_stmt->loc        = nodes[0]->loc;
src/AST/build.cpp:215:  for_stmt->statements = steal<Statements>(nodes[3]);
src/AST/build.cpp:219:  if (iter->is_comma_list()) {
src/AST/build.cpp:221:    for_stmt->iterators.reserve(iter_list->exprs.size());
src/AST/build.cpp:223:    for (auto &ex : iter_list->exprs) {
src/AST/build.cpp:224:      CheckForLoopDeclaration(ex, for_stmt->iterators);
src/AST/build.cpp:231:    CheckForLoopDeclaration(iter, for_stmt->iterators);
src/AST/build.cpp:245:  unop_ptr->operand = steal<AST::Expression>(nodes[1]);
src/AST/build.cpp:249:  unop_ptr->loc = nodes[0]->loc;
src/AST/build.cpp:251:  assert(nodes[0]->is_token_node());
src/AST/build.cpp:252:  auto tk = static_cast<TokenNode *>(nodes[0])->token;
src/AST/build.cpp:256:    // the programs/ directory for now, we hard-code that. This needs to be
src/AST/build.cpp:258:    assert(unop_ptr->operand->is_terminal() &&
src/AST/build.cpp:259:           static_cast<Terminal *>(unop_ptr->operand)->terminal_type ==
src/AST/build.cpp:262:                       std::string(unop_ptr->operand->value.as_str));
src/AST/build.cpp:264:    unop_ptr->op = Language::Operator::Import;
src/AST/build.cpp:267:    unop_ptr->op = Language::Operator::Return;
src/AST/build.cpp:270:    unop_ptr->op = Language::Operator::Break;
src/AST/build.cpp:274:    unop_ptr->op = Language::Operator::Continue;
src/AST/build.cpp:278:    unop_ptr->op = Language::Operator::Restart;
src/AST/build.cpp:282:    unop_ptr->op = Language::Operator::Repeat;
src/AST/build.cpp:286:    unop_ptr->op = Language::Operator::Free;
src/AST/build.cpp:289:    unop_ptr->op = Language::Operator::Print;
src/AST/build.cpp:292:    unop_ptr->op = Language::Operator::And;
src/AST/build.cpp:294:  } else if (tk == "-") {
src/AST/build.cpp:295:    unop_ptr->op = Language::Operator::Sub;
src/AST/build.cpp:298:    unop_ptr->op = Language::Operator::Not;
src/AST/build.cpp:301:    unop_ptr->op = Language::Operator::At;
src/AST/build.cpp:307:  unop_ptr->precedence = Language::precedence(unop_ptr->op);
src/AST/build.cpp:309:  if (unop_ptr->operand->is_declaration()) {
src/AST/build.cpp:310:    auto decl = static_cast<Declaration *>(unop_ptr->operand);
src/AST/build.cpp:311:    error_log.log(decl->loc, "Invalid use of declaration.");
src/AST/build.cpp:317:  unop_ptr->precedence = Language::precedence(unop_ptr->op);
src/AST/build.cpp:318:  if (!unop_ptr->operand->is_identifier()) {
src/AST/build.cpp:319:    error_log.log(unop_ptr->operand->loc,
src/AST/build.cpp:332:  auto op_prec = Language::precedence(op_node->op);
src/AST/build.cpp:339:      nodes[0]->is_chain_op() &&
src/AST/build.cpp:340:      static_cast<ChainOp *>(nodes[0])->precedence == op_prec;
src/AST/build.cpp:347:    chain_ptr->loc = nodes[1]->loc;
src/AST/build.cpp:349:    chain_ptr->exprs.push_back(steal<Expression>(nodes[0]));
src/AST/build.cpp:351:    chain_ptr->precedence = op_prec;
src/AST/build.cpp:354:  chain_ptr->ops.push_back(op_node->op);
src/AST/build.cpp:355:  chain_ptr->exprs.push_back(steal<Expression>(nodes[2]));
src/AST/build.cpp:368:  access_ptr->loc     = nodes[0]->loc;
src/AST/build.cpp:369:  access_ptr->operand = steal<Expression>(nodes[0]);
src/AST/build.cpp:371:  if (access_ptr->operand->is_declaration()) {
src/AST/build.cpp:372:    error_log.log(access_ptr->operand->loc,
src/AST/build.cpp:373:                  "Left-hand side cannot be a declaration");
src/AST/build.cpp:376:  if (!nodes[2]->is_identifier()) {
src/AST/build.cpp:377:    error_log.log(nodes[2]->loc, "Right-hand side must be an identifier");
src/AST/build.cpp:379:    access_ptr->member_name = static_cast<Identifier *>(nodes[2])->token;
src/AST/build.cpp:387:  binop_ptr->loc = nodes[1]->loc;
src/AST/build.cpp:389:  binop_ptr->lhs       = steal<Expression>(nodes[0]);
src/AST/build.cpp:390:  binop_ptr->rhs       = steal<Expression>(nodes[2]);
src/AST/build.cpp:391:  binop_ptr->op        = op_class;
src/AST/build.cpp:393:  if (binop_ptr->lhs->is_declaration()) {
src/AST/build.cpp:394:    error_log.log(binop_ptr->lhs->loc,
src/AST/build.cpp:395:                  "Left-hand side cannot be a declaration");
src/AST/build.cpp:398:  if (binop_ptr->rhs->is_declaration()) {
src/AST/build.cpp:399:    error_log.log(binop_ptr->rhs->loc, "Right-hand side cannot be a "
src/AST/build.cpp:404:  binop_ptr->precedence = Language::precedence(binop_ptr->op);
src/AST/build.cpp:437:  array_lit_ptr->loc = nodes[0]->loc;
src/AST/build.cpp:447:  unop_ptr->operand = steal<Expression>(nodes[0]);
src/AST/build.cpp:452:  unop_ptr->loc       = tk_node->loc;
src/AST/build.cpp:453:  unop_ptr->op        = tk_node->op;
src/AST/build.cpp:455:  unop_ptr->precedence = Language::precedence(unop_ptr->op);
src/AST/build.cpp:461:  array_lit_ptr->loc = nodes[0]->loc;
src/AST/build.cpp:463:  if (nodes[1]->is_comma_list()) {
src/AST/build.cpp:465:    swap(array_lit_ptr->elems, static_cast<ChainOp *>(nodes[1])->exprs);
src/AST/build.cpp:468:    array_lit_ptr->elems.push_back(steal<Expression>(nodes[1]));
src/AST/build.cpp:475:  if (nodes[1]->is_comma_list()) {
src/AST/build.cpp:477:    auto iter         = length_chain->exprs.rbegin();
src/AST/build.cpp:480:    while (iter != length_chain->exprs.rend()) {
src/AST/build.cpp:482:      array_type_ptr->loc       = (*iter)->loc;
src/AST/build.cpp:483:      array_type_ptr->length    = *iter;
src/AST/build.cpp:485:      array_type_ptr->data_type = prev;
src/AST/build.cpp:494:    array_type_ptr->loc       = nodes[0]->loc;
src/AST/build.cpp:495:    array_type_ptr->length    = steal<Expression>(nodes[1]);
src/AST/build.cpp:496:    array_type_ptr->data_type = steal<Expression>(nodes[3]);
src/AST/build.cpp:510:  assert(nodes[1]->is_token_node());
src/AST/build.cpp:511:  decl->hashtags.push_back(static_cast<TokenNode *>(nodes[1])->token);
src/AST/build.cpp:517:  auto op = ((AST::TokenNode *)(nodes[1]))->op;
src/AST/build.cpp:521:  in_decl_ptr->loc        = nodes[1]->loc;
src/AST/build.cpp:522:  in_decl_ptr->identifier = steal<Identifier>(nodes[0]);
src/AST/build.cpp:523:  in_decl_ptr->container  = steal<Expression>(nodes[2]);
src/AST/build.cpp:524:  in_decl_ptr->precedence = Language::precedence(Language::Operator::In);
src/AST/build.cpp:529:  auto op              = ((AST::TokenNode *)(nodes[1]))->op;
src/AST/build.cpp:531:  decl_ptr->loc        = nodes[1]->loc;
src/AST/build.cpp:532:  decl_ptr->precedence = Language::precedence(op);
src/AST/build.cpp:535:    decl_ptr->type_expr = steal<Expression>(nodes[2]);
src/AST/build.cpp:537:    decl_ptr->init_val  = steal<Expression>(nodes[2]);
src/AST/build.cpp:540:  assert(nodes[0]->is_identifier());
src/AST/build.cpp:541:  decl_ptr->identifier = steal<Identifier>(nodes[0]);
src/AST/build.cpp:550:  generic->loc        = nodes[1]->loc;
src/AST/build.cpp:551:  generic->test_fn    = steal<Expression>(nodes[0]);
src/AST/build.cpp:552:  generic->precedence = Language::precedence(Language::Operator::Tick);
src/AST/build.cpp:557:  assert(nodes[2]->is_identifier());
src/AST/build.cpp:558:  generic->identifier = steal<Identifier>(nodes[2]);
src/AST/build.cpp:570:  nodes[nodes.size() - 2] = new Statements;
src/AST/build.cpp:577:  fn_lit->loc = nodes[0]->loc;
src/AST/build.cpp:579:  if (nodes[2]->is_statements()) {
src/AST/build.cpp:580:    fn_lit->statements = steal<Statements>(nodes[2]);
src/AST/build.cpp:582:    fn_lit->statements = new Statements;
src/AST/build.cpp:589:  fn_lit->return_type_expr = steal<Expression>(binop_ptr->rhs);
src/AST/build.cpp:590:  auto input_args          = steal<Expression>(binop_ptr->lhs);
src/AST/build.cpp:593:  // of the form (int -> int) -> int? I'm not sure how robust this is
src/AST/build.cpp:594:  if (input_args->is_declaration()) {
src/AST/build.cpp:595:    fn_lit->inputs.push_back(static_cast<Declaration *>(input_args));
src/AST/build.cpp:597:  } else if (input_args->is_comma_list()) {
src/AST/build.cpp:601:    fn_lit->inputs.resize(decl_list->exprs.size(), nullptr);
src/AST/build.cpp:604:    for (auto &&expr : decl_list->exprs) {
src/AST/build.cpp:605:      fn_lit->inputs[index++] = steal<Declaration>(expr);
src/AST/build.cpp:616:  output->statements.push_back(steal<Node>(nodes[0]));
src/AST/build.cpp:623:  output->statements.push_back(steal<Node>(nodes[1]));
src/AST/build.cpp:632:  assert(else_if->conditions.size() == 1 && else_if->statements.size() == 1 &&
src/AST/build.cpp:633:         else_if->body_scopes.size() == 1 && "Else-if statement constructed by "
src/AST/build.cpp:637:  if_stmt->conditions.push_back(else_if->conditions.front());
src/AST/build.cpp:638:  if_stmt->statements.push_back(else_if->statements.front());
src/AST/build.cpp:639:  if_stmt->body_scopes.push_back(new BlockScope(ScopeType::Conditional));
src/AST/build.cpp:645:  if_stmt->else_line_num = nodes[1]->loc.line_num;
src/AST/build.cpp:646:  if_stmt->statements.push_back(steal<Statements>(nodes[3]));
src/AST/build.cpp:647:  if_stmt->body_scopes.push_back(new BlockScope(ScopeType::Conditional));
src/AST/build.cpp:658:  nodes[nodes.size() - 2] = new Statements;
src/AST/build.cpp:664:  assert(nodes[0]->is_token_node());
src/AST/build.cpp:665:  auto tk = static_cast<TokenNode *>(nodes[0])->token;
src/AST/build.cpp:667:    return new Jump(nodes[0]->loc, JumpType::Break);
src/AST/build.cpp:670:    return new Jump(nodes[0]->loc, JumpType::Continue);
src/AST/build.cpp:673:    return new Jump(nodes[0]->loc, JumpType::Return);
src/AST/build.cpp:676:    return new Jump(nodes[0]->loc, JumpType::Repeat);
src/AST/build.cpp:679:    return new Jump(nodes[0]->loc, JumpType::Restart);
src/AST/build.cpp:695:  assert(nodes[1]->is_token_node());
src/AST/build.cpp:696:  auto tk = static_cast<AST::TokenNode *>(nodes[1])->token;
src/AST/build.cpp:700:      static_cast<AST::TokenNode *>(nodes[1])->op = op.second;
src/AST/build.cpp:719:    if (nodes[0]->is_declaration()) {
src/AST/build.cpp:722:      decl->init_val = steal<AST::Expression>(nodes[2]);
src/AST/build.cpp:726:      binop_ptr->loc = nodes[1]->loc;
src/AST/build.cpp:728:      binop_ptr->lhs = steal<AST::Expression>(nodes[0]);
src/AST/build.cpp:729:      binop_ptr->rhs = steal<AST::Expression>(nodes[2]);
src/AST/build.cpp:731:      binop_ptr->op         = Language::Operator::Assign;
src/AST/build.cpp:732:      binop_ptr->precedence = Language::precedence(binop_ptr->op);
src/AST/build.cpp:738:  binop_ptr->loc = nodes[1]->loc;
src/AST/build.cpp:740:  binop_ptr->lhs       = steal<AST::Expression>(nodes[0]);
src/AST/build.cpp:741:  binop_ptr->rhs       = steal<AST::Expression>(nodes[2]);
src/AST/build.cpp:745:    binop_ptr->op = Language::Operator::name;                                  \
src/AST/build.cpp:751:  LOOKUP_SYMBOL("->", Arrow)
src/AST/build.cpp:756:  LOOKUP_SYMBOL("-=", SubEq)
src/AST/build.cpp:762:  LOOKUP_SYMBOL("-", Sub)
src/AST/build.cpp:770:  binop_ptr->precedence = Language::precedence(binop_ptr->op);
src/AST/build.cpp:776:  assert(nodes[0]->is_token_node());
src/AST/build.cpp:777:  auto tk = static_cast<AST::TokenNode *>(nodes[0])->token;
src/AST/build.cpp:799:  nodes[nodes.size() - 2] = new AST::Statements;
src/AST/build.cpp:805:  assert(nodes[0]->is_token_node());
src/AST/build.cpp:806:  auto tk = static_cast<AST::TokenNode *>(nodes[0])->token;
src/AST/build.cpp:831:  nodes[nodes.size() - 2] = new AST::Statements;
src/AST/build.cpp:838:  expr_ptr->precedence =
src/AST/clone.cpp:19:  cache_loc->data.ids.reserve(num);
src/AST/clone.cpp:20:  cache_loc->data.types.reserve(num);
src/AST/clone.cpp:21:  cache_loc->data.init_vals.reserve(num);
src/AST/clone.cpp:29:    auto new_type = curr_type_expr->evaluate(arg_vals).as_type;
src/AST/clone.cpp:31:    cache_loc->data.ids.push_back(curr_id);
src/AST/clone.cpp:32:    cache_loc->data.types.push_back(new_type);
src/AST/clone.cpp:33:    cache_loc->data.init_vals.push_back(nullptr); // TODO
src/AST/clone.cpp:34:    cache_loc->data.type_exprs.push_back(
src/AST/clone.cpp:35:        new DummyTypeExpr(curr_type_expr->loc, new_type));
src/AST/clone.cpp:37:    cache_loc->value.as_type->has_vars |=
src/AST/clone.cpp:38:        cache_loc->data.types.back()->has_vars;
src/AST/clone.cpp:41:  delete cache_loc->type_scope;
src/AST/clone.cpp:42:  cache_loc->type_scope = type_scope;
src/AST/clone.cpp:43:  cache_loc->scope_ = scope_; // Same scope as original.
src/AST/clone.cpp:44:  cache_loc->verify_types();
src/AST/clone.cpp:46:  cache_loc->value.as_type->has_vars = has_vars;
src/AST/clone.cpp:47:  if (!has_vars) { cache_loc->CompleteDefinition(); }
src/AST/clone.cpp:49:  assert(value.as_type->is_parametric_struct());
src/AST/clone.cpp:50:  assert(cache_loc->value.as_type->is_struct());
src/AST/clone.cpp:51:  static_cast<Structure *>(cache_loc->value.as_type)->creator = this;
src/AST/clone.cpp:68:  fn_lit->return_type_expr = (Expression *)return_type_expr->CLONE;
src/AST/clone.cpp:69:  fn_lit->statements       = (Statements *)statements->CLONE;
src/AST/clone.cpp:70:  fn_lit->code_gened       = code_gened;
src/AST/clone.cpp:73:    fn_lit->inputs.push_back((Declaration *)input->CLONE);
src/AST/clone.cpp:82:  array_lit->elems.reserve(elems.size());
src/AST/clone.cpp:83:  for (auto el : elems) { array_lit->elems.push_back((Expression *)el->CLONE); }
src/AST/clone.cpp:89:  binop->op  = op;
src/AST/clone.cpp:90:  binop->lhs = (Expression *)lhs->CLONE;
src/AST/clone.cpp:91:  if (rhs) { binop->rhs = (Expression *)rhs->CLONE; }
src/AST/clone.cpp:97:  for_stmt->statements = (Statements *)statements->CLONE;
src/AST/clone.cpp:99:  for_stmt->iterators.reserve(iterators.size());
src/AST/clone.cpp:101:    for_stmt->iterators.push_back((InDecl *)i->CLONE);
src/AST/clone.cpp:109:  for (auto s : statements) { stmts->statements.push_back(s->CLONE); }
src/AST/clone.cpp:116:  array_type->length    = (Expression *)length->CLONE;
src/AST/clone.cpp:117:  array_type->data_type = (Expression *)data_type->CLONE;
src/AST/clone.cpp:123:  unop->op      = op;
src/AST/clone.cpp:124:  unop->operand = (Expression *)operand->CLONE;
src/AST/clone.cpp:131:  cond_node->else_line_num = else_line_num;
src/AST/clone.cpp:133:  cond_node->conditions.reserve(conditions.size());
src/AST/clone.cpp:135:    cond_node->conditions.push_back((Expression *)c->CLONE);
src/AST/clone.cpp:138:  cond_node->statements.reserve(conditions.size());
src/AST/clone.cpp:140:    cond_node->statements.push_back((Statements *)s->CLONE);
src/AST/clone.cpp:144:  cond_node->body_scopes.reserve(num_body_scopes);
src/AST/clone.cpp:147:    cond_node->body_scopes.push_back(new BlockScope(ScopeType::Conditional));
src/AST/clone.cpp:155:  chain_node->ops = ops;
src/AST/clone.cpp:157:  chain_node->exprs.reserve(exprs.size());
src/AST/clone.cpp:158:  for (auto e : exprs) { chain_node->exprs.push_back((Expression *)e->CLONE); }
src/AST/clone.cpp:168:    case_node->key_vals.emplace_back((Expression *)kv.first->CLONE,
src/AST/clone.cpp:169:                                     (Expression *)kv.second->CLONE);
src/AST/clone.cpp:177:  access_node->member_name = member_name;
src/AST/clone.cpp:178:  access_node->operand     = (Expression *)operand->CLONE;
src/AST/clone.cpp:185:    if (identifier == lookup_key[i]->identifier) {
src/AST/clone.cpp:191:  generic->identifier = (Identifier *)identifier->CLONE;
src/AST/clone.cpp:192:  generic->test_fn    = (Expression *)test_fn->CLONE;
src/AST/clone.cpp:198:  in_decl->identifier = (Identifier *)identifier->CLONE;
src/AST/clone.cpp:199:  in_decl->container  = (Expression *)container->CLONE;
src/AST/clone.cpp:205:  decl->identifier = (Identifier *)identifier->CLONE;
src/AST/clone.cpp:206:  decl->hashtags   = hashtags;
src/AST/clone.cpp:208:  if (type_expr) { decl->type_expr = (Expression *)type_expr->CLONE; }
src/AST/clone.cpp:209:  if (init_val) { decl->init_val = (Expression *)init_val->CLONE; }
src/AST/clone.cpp:216:    if (this == lookup_key[i]->identifier) {
src/AST/ctors.cpp:22:    op = iter->second;
src/AST/evaluate.cpp:51:    os << val.as_type->to_string();
src/AST/evaluate.cpp:61:  assert(value.as_type->is_parametric_struct());
src/AST/evaluate.cpp:72:        std::cerr << "   - Parameter number mismatch (" << num_args << " vs "
src/AST/evaluate.cpp:81:          std::cerr << "   - Failed matching argument " << kv.first
src/AST/evaluate.cpp:90:      std::cerr << "   - Found a match." << std::endl;
src/AST/evaluate.cpp:94:    return cached_val.second->value;
src/AST/evaluate.cpp:103:  ss << param_struct->bound_name << "(";
src/AST/evaluate.cpp:106:  if (params[0]->type_expr) {
src/AST/evaluate.cpp:108:    parameter_type = params[0]->type_expr->evaluate(ctx).as_type;
src/AST/evaluate.cpp:110:    assert(params[0]->init_val);
src/AST/evaluate.cpp:111:    params[0]->init_val->verify_types();
src/AST/evaluate.cpp:112:    parameter_type = params[0]->init_val->type;
src/AST/evaluate.cpp:115:  AppendValueToStream(parameter_type, arg_vals.at(params[0]->identifier->token),
src/AST/evaluate.cpp:119:    if (params[0]->type_expr) {
src/AST/evaluate.cpp:121:      parameter_type = params[i]->type_expr->evaluate(ctx).as_type;
src/AST/evaluate.cpp:123:      assert(params[i]->init_val);
src/AST/evaluate.cpp:124:      params[i]->init_val->verify_types();
src/AST/evaluate.cpp:125:      parameter_type = params[i]->init_val->type;
src/AST/evaluate.cpp:130:                        arg_vals.at(params[0]->identifier->token), ss);
src/AST/evaluate.cpp:134:  cache_loc->value = Context::Value(Struct(ss.str(), cache_loc));
src/AST/evaluate.cpp:147:      param_struct->ast_expression->CloneStructLiteral(cache_loc);
src/AST/evaluate.cpp:149:  cloned_struct->verify_types();
src/AST/evaluate.cpp:150:  static_cast<Structure *>(cloned_struct->value.as_type)->set_name(ss.str());
src/AST/evaluate.cpp:152:  return cloned_struct->value;
src/AST/evaluate.cpp:175:    if (iter != ctx.end()) { return iter->second; }
src/AST/evaluate.cpp:180:  if (type == Type_ && !value.as_type) { decl->evaluate(ctx); }
src/AST/evaluate.cpp:182:  decl->evaluate(ctx);
src/AST/evaluate.cpp:183:  value = decl->value;
src/AST/evaluate.cpp:195:    scope_->SetCTRV(operand->evaluate(ctx));
src/AST/evaluate.cpp:201:    auto val = operand->evaluate(ctx);
src/AST/evaluate.cpp:202:    if (operand->type == Bool)
src/AST/evaluate.cpp:204:    else if (operand->type == Char)
src/AST/evaluate.cpp:206:    else if (operand->type == Int)
src/AST/evaluate.cpp:208:    else if (operand->type == Real)
src/AST/evaluate.cpp:210:    else if (operand->type == Type_)
src/AST/evaluate.cpp:211:      std::cout << val.as_type->to_string();
src/AST/evaluate.cpp:212:    else if (operand->type == Uint)
src/AST/evaluate.cpp:225:      return Context::Value(-operand->evaluate(ctx).as_int);
src/AST/evaluate.cpp:229:      return Context::Value(-operand->evaluate(ctx).as_real);
src/AST/evaluate.cpp:232:    if (operand->type != Type_) {
src/AST/evaluate.cpp:235:                             operand->type->to_string() +
src/AST/evaluate.cpp:236:                             " is not allowed at compile-time");
src/AST/evaluate.cpp:240:    return value = Context::Value(Ptr(operand->evaluate(ctx).as_type));
src/AST/evaluate.cpp:250:  auto expr_type = exprs[0]->type;
src/AST/evaluate.cpp:256:        expr_val = (expr_val != expr->evaluate(ctx).as_bool);
src/AST/evaluate.cpp:262:        if (expr->evaluate(ctx).as_bool) return value = Context::Value(false);
src/AST/evaluate.cpp:267:        if (expr->evaluate(ctx).as_bool) { return value = Context::Value(true); }
src/AST/evaluate.cpp:277:    auto last = exprs[0]->evaluate(ctx);
src/AST/evaluate.cpp:279:      auto next = exprs[i + 1]->evaluate(ctx);
src/AST/evaluate.cpp:303:        types.push_back(exprs[i]->evaluate(ctx).as_type);
src/AST/evaluate.cpp:309:    auto last = exprs[0]->evaluate(ctx);
src/AST/evaluate.cpp:311:      auto next = exprs[i + 1]->evaluate(ctx);
src/AST/evaluate.cpp:328:    auto last = exprs[0]->evaluate(ctx);
src/AST/evaluate.cpp:330:      auto next = exprs[i + 1]->evaluate(ctx);
src/AST/evaluate.cpp:351:    auto last = exprs[0]->evaluate(ctx);
src/AST/evaluate.cpp:353:      auto next = exprs[i + 1]->evaluate(ctx);
src/AST/evaluate.cpp:372:  } else if (expr_type->is_enum()) {
src/AST/evaluate.cpp:374:    auto last = exprs[0]->evaluate(ctx);
src/AST/evaluate.cpp:376:      auto next = exprs[i + 1]->evaluate(ctx);
src/AST/evaluate.cpp:399:  // TODO what if the length is given but isn't a compile-time value? e.g.,
src/AST/evaluate.cpp:401:  //   [input(int); char] // a char-array of length given by user input
src/AST/evaluate.cpp:402:  auto data_type_eval = data_type->evaluate(ctx).as_type;
src/AST/evaluate.cpp:403:  if (length->is_hole()) {
src/AST/evaluate.cpp:406:    auto length_eval = length->evaluate(ctx).as_uint;
src/AST/evaluate.cpp:428:    if (kv.first->evaluate(ctx).as_bool) { return kv.second->evaluate(ctx); }
src/AST/evaluate.cpp:430:  // Must have an else-clause, so this is unreachable.
src/AST/evaluate.cpp:441:  value = identifier->value = Context::Value(TypeVar(identifier, test_fn));
src/AST/evaluate.cpp:449:    if (init_val->type->is_function()) {
src/AST/evaluate.cpp:453:      value = init_val->evaluate(ctx);
src/AST/evaluate.cpp:455:      if (init_val->is_struct_literal()) {
src/AST/evaluate.cpp:456:        assert(identifier->value.as_type->is_struct());
src/AST/evaluate.cpp:457:        ((Structure *)(identifier->value.as_type))->set_name(identifier->token);
src/AST/evaluate.cpp:459:      } else if (init_val->is_parametric_struct_literal()) {
src/AST/evaluate.cpp:460:        assert(identifier->value.as_type->is_parametric_struct());
src/AST/evaluate.cpp:461:        ((ParametricStructure *)(identifier->value.as_type))
src/AST/evaluate.cpp:462:            ->set_name(identifier->token);
src/AST/evaluate.cpp:464:      } else if (init_val->is_enum_literal()) {
src/AST/evaluate.cpp:465:        assert(identifier->value.as_type->is_enum());
src/AST/evaluate.cpp:466:        ((Enumeration *)(identifier->value.as_type))->bound_name =
src/AST/evaluate.cpp:467:            identifier->token;
src/AST/evaluate.cpp:471:    if (type_expr->type == Type_) {
src/AST/evaluate.cpp:473:    } else if (type_expr->type->is_type_variable()) {
src/AST/evaluate.cpp:487:  if (type->is_enum()) {
src/AST/evaluate.cpp:489:    return Context::Value(enum_type->get_index(member_name));
src/AST/evaluate.cpp:493:    return Context::Value(operand->evaluate(ctx).as_type->bytes());
src/AST/evaluate.cpp:496:    return Context::Value(operand->evaluate(ctx).as_type->alignment());
src/AST/evaluate.cpp:507:    if (lhs->type->is_function()) {
src/AST/evaluate.cpp:508:      auto lhs_val = lhs->evaluate(ctx).as_expr;
src/AST/evaluate.cpp:509:      assert(lhs_val && lhs_val->is_function_literal());
src/AST/evaluate.cpp:514:      if (rhs->is_comma_list()) {
src/AST/evaluate.cpp:515:        arg_vals = ((ChainOp *)rhs)->exprs;
src/AST/evaluate.cpp:520:      assert(arg_vals.size() == fn_ptr->inputs.size());
src/AST/evaluate.cpp:525:        if (a->type == Bool) {
src/AST/evaluate.cpp:526:          args.emplace_back(a->evaluate(ctx).as_bool);
src/AST/evaluate.cpp:527:        } else if (a->type == Char) {
src/AST/evaluate.cpp:528:          args.emplace_back(a->evaluate(ctx).as_char);
src/AST/evaluate.cpp:529:        } else if (a->type == Int) {
src/AST/evaluate.cpp:530:          args.emplace_back((int)a->evaluate(ctx).as_int);
src/AST/evaluate.cpp:531:        } else if (a->type == Real) {
src/AST/evaluate.cpp:532:          args.emplace_back(a->evaluate(ctx).as_real);
src/AST/evaluate.cpp:533:        } else if (a->type == Uint) {
src/AST/evaluate.cpp:534:          args.emplace_back(a->evaluate(ctx).as_uint);
src/AST/evaluate.cpp:535:        } else if (a->type == Type_) {
src/AST/evaluate.cpp:536:          args.emplace_back(a->evaluate(ctx).as_type);
src/AST/evaluate.cpp:543:      IR::Func *func   = fn_ptr->EmitIR().val.as_func;
src/AST/evaluate.cpp:568:    } else if (lhs->type == Type_) {
src/AST/evaluate.cpp:569:      auto lhs_evaled = lhs->evaluate(ctx).as_type;
src/AST/evaluate.cpp:571:      assert(lhs_evaled->is_parametric_struct());
src/AST/evaluate.cpp:574:          static_cast<ParametricStructure *>(lhs_evaled)->ast_expression;
src/AST/evaluate.cpp:576:      assert(struct_lit->value.as_type);
src/AST/evaluate.cpp:577:      assert(struct_lit->value.as_type->is_parametric_struct());
src/AST/evaluate.cpp:580:        assert(struct_lit->value.as_type);
src/AST/evaluate.cpp:581:        assert(struct_lit->value.as_type->is_parametric_struct());
src/AST/evaluate.cpp:584:                         struct_lit->value.as_type)
src/AST/evaluate.cpp:585:                         ->bound_name
src/AST/evaluate.cpp:598:      if (rhs->is_comma_list()) {
src/AST/evaluate.cpp:601:        const auto &elems = static_cast<ChainOp*>(rhs)->exprs;
src/AST/evaluate.cpp:603:          auto evaled_elem = elems[i]->evaluate(ctx);
src/AST/evaluate.cpp:604:          param_struct_args[struct_lit->params[i]->identifier->token] = evaled_elem;
src/AST/evaluate.cpp:611:        auto evaled_rhs = rhs->evaluate(ctx);
src/AST/evaluate.cpp:612:        param_struct_args[struct_lit->params[0]->identifier->token] = rhs->evaluate(ctx);
src/AST/evaluate.cpp:622:      return value = struct_lit->CreateOrGetCached(param_struct_args);
src/AST/evaluate.cpp:629:    auto lhs_type = lhs->evaluate(ctx).as_type;
src/AST/evaluate.cpp:630:    auto rhs_type = rhs->evaluate(ctx).as_type;
src/AST/evaluate.cpp:639:    stmt->evaluate(ctx);
src/AST/evaluate.cpp:640:    if (scope_->HasCTRV()) {
src/AST/evaluate.cpp:641:      return scope_->GetCTRV();
src/AST/evaluate.cpp:650:    if (conditions[i]->evaluate(ctx).as_bool) {
src/AST/evaluate.cpp:651:      statements[i]->evaluate(ctx);
src/AST/evaluate.cpp:652:      if (scope_->HasCTRV()) { return scope_->GetCTRV(); }
src/AST/evaluate.cpp:657:    statements.back()->evaluate(ctx);
src/AST/evaluate.cpp:658:    if (scope_->HasCTRV()) { return scope_->GetCTRV(); }
src/AST/generate_code.cpp:63:      global_module->getOrInsertFunction(name, llvm_fn_type));
src/AST/generate_code.cpp:68:  // TODO multiple args, multiple return values, non-primitives, void return
src/AST/generate_code.cpp:69:  auto arg = llvm_fn->args().begin();
src/AST/generate_code.cpp:81:  } else if (type->is_function()) {
src/AST/generate_code.cpp:84:    auto llvm_fn_type = (llvm::FunctionType *)fn_type->llvm_type;
src/AST/generate_code.cpp:87:    return global_module->getOrInsertFunction(mangled_name, llvm_fn_type);
src/AST/generate_code.cpp:89:  } else if (type->is_big()) {
src/AST/generate_code.cpp:113:                    static_cast<Structure *>(String)->field_num("_length")},
src/AST/generate_code.cpp:119:                    static_cast<Structure *>(String)->field_num("_chars")},
src/AST/generate_code.cpp:123:    Arr(Char)->initialize_literal(char_array_ptr, len);
src/AST/generate_code.cpp:139:  if (expr->type == Type_) {
src/AST/generate_code.cpp:144:         data::global_string(expr->evaluate(ctx).as_type->to_string())});
src/AST/generate_code.cpp:148:  llvm::Value *val = expr->generate_code();
src/AST/generate_code.cpp:155:  if (expr->type->is_struct()) {
src/AST/generate_code.cpp:157:    auto print_fn = GetFunctionReferencedIn(expr->scope_, "__print__", expr->type);
src/AST/generate_code.cpp:161:  } else if (expr->type == Char) {
src/AST/generate_code.cpp:164:  } else if (expr->type == Uint) {
src/AST/generate_code.cpp:168:    expr->type->call_repr(val);
src/AST/generate_code.cpp:180:    return operand->generate_lvalue();
src/AST/generate_code.cpp:183:    if (operand->is_comma_list()) {
src/AST/generate_code.cpp:184:      for (auto expr: static_cast<ChainOp *>(operand)->exprs) {
src/AST/generate_code.cpp:195:  llvm::Value *val = operand->generate_code();
src/AST/generate_code.cpp:198:    if (operand->type == Bool) {
src/AST/generate_code.cpp:201:      auto not_fn = GetFunctionReferencedIn(scope_, "__not__", operand->type);
src/AST/generate_code.cpp:207:    if (operand->type == Int) {
src/AST/generate_code.cpp:210:    } else if (operand->type == Real) {
src/AST/generate_code.cpp:213:    } else if (operand->type->is_struct()) {
src/AST/generate_code.cpp:214:      auto neg_fn = GetFunctionReferencedIn(scope_, "__neg__", operand->type);
src/AST/generate_code.cpp:219:      assert(scope_->is_block_scope());
src/AST/generate_code.cpp:220:      auto local_ret = ((BlockScope *)scope_)->CreateLocalReturn(type);
src/AST/generate_code.cpp:230:    if (operand->lvalue) {
src/AST/generate_code.cpp:231:      builder.CreateStore(data::null(operand->type),
src/AST/generate_code.cpp:232:                          operand->generate_lvalue());
src/AST/generate_code.cpp:238:    assert(scope_->is_block_scope());
src/AST/generate_code.cpp:239:    static_cast<BlockScope *>(scope_)->make_return(val);
src/AST/generate_code.cpp:243:    return type->is_big() ? val : builder.CreateLoad(val);
src/AST/generate_code.cpp:250:  if (operand->type == Type_) {
src/AST/generate_code.cpp:261:    auto expr_as_type = operand->evaluate(ctx).as_type;
src/AST/generate_code.cpp:264:    // compile-time) Remove it from here.
src/AST/generate_code.cpp:266:      return data::const_uint(expr_as_type->bytes());
src/AST/generate_code.cpp:269:      return data::const_uint(expr_as_type->alignment());
src/AST/generate_code.cpp:272:    assert(expr_as_type->is_enum() && "Expression should be an enum");
src/AST/generate_code.cpp:273:    return static_cast<Enumeration *>(expr_as_type)->get_value(member_name);
src/AST/generate_code.cpp:275:  } else if (operand->type->is_array() && member_name == "size" &&
src/AST/generate_code.cpp:276:             static_cast<Array *>(operand->type)->fixed_length) {
src/AST/generate_code.cpp:277:    // Fixed length arrays shouldn't bother to do any real code-gen
src/AST/generate_code.cpp:278:    return data::const_uint(static_cast<Array *>(operand->type)->len);
src/AST/generate_code.cpp:282:  auto eval = operand->generate_code();
src/AST/generate_code.cpp:286:  auto base_type = operand->type;
src/AST/generate_code.cpp:287:  while (base_type->is_pointer()) {
src/AST/generate_code.cpp:288:    base_type = static_cast<Pointer *>(base_type)->pointee;
src/AST/generate_code.cpp:289:    if (!base_type->is_big()) eval = builder.CreateLoad(eval);
src/AST/generate_code.cpp:292:  if (base_type->is_array() && member_name == "size") {
src/AST/generate_code.cpp:297:  if (base_type->is_struct()) {
src/AST/generate_code.cpp:300:    if (!type->stores_data()) { assert(false && "Not yet implemented"); }
src/AST/generate_code.cpp:303:        eval, {data::const_uint(0), struct_type->field_num(member_name)});
src/AST/generate_code.cpp:304:    return type->is_big() ? elem_ptr : builder.CreateLoad(elem_ptr);
src/AST/generate_code.cpp:318:  if (lhs->is_identifier() && rhs->type->is_function()) {
src/AST/generate_code.cpp:320:    auto fn_type      = (Function *)rhs->type;
src/AST/generate_code.cpp:321:    auto llvm_fn_type = (llvm::FunctionType *)fn_type->llvm_type;
src/AST/generate_code.cpp:326:    if (rhs->is_function_literal()) {
src/AST/generate_code.cpp:328:      fn->fn_scope->name = id->token;
src/AST/generate_code.cpp:330:      fn->llvm_fn = static_cast<llvm::Function *>(
src/AST/generate_code.cpp:331:          global_module->getOrInsertFunction(mangled_name, llvm_fn_type));
src/AST/generate_code.cpp:333:    } else if (rhs->is_binop() &&
src/AST/generate_code.cpp:334:               static_cast<Binop *>(rhs)->op == Language::Operator::Mul) {
src/AST/generate_code.cpp:336:      auto lhs_val = binop->lhs->generate_code();
src/AST/generate_code.cpp:337:      auto rhs_val = binop->rhs->generate_code();
src/AST/generate_code.cpp:342:    val = rhs->generate_code();
src/AST/generate_code.cpp:346:    if (val) { val->setName(mangled_name); }
src/AST/generate_code.cpp:349:    var = lhs->generate_lvalue();
src/AST/generate_code.cpp:352:    if (rhs->is_terminal() &&
src/AST/generate_code.cpp:353:        static_cast<Terminal *>(rhs)->terminal_type ==
src/AST/generate_code.cpp:357:    val = rhs->generate_code();
src/AST/generate_code.cpp:360:    Type::CallAssignment(lhs->scope_, lhs->type, rhs->type, var, val);
src/AST/generate_code.cpp:367:  if (arg->is_comma_list()) {
src/AST/generate_code.cpp:368:    auto &arg_exprs = static_cast<ChainOp *>(arg)->exprs;
src/AST/generate_code.cpp:374:      arg_vals[i] = arg_exprs[i]->generate_code();
src/AST/generate_code.cpp:380:  return {arg->generate_code()};
src/AST/generate_code.cpp:391:  // The left-hand side may be a declaration
src/AST/generate_code.cpp:394:        (lhs->is_declaration() ? static_cast<Declaration *>(lhs)->identifier
src/AST/generate_code.cpp:402:      assert(lhs->type->is_function() && "Operand should be a function.");
src/AST/generate_code.cpp:403:      auto out_type = static_cast<Function *>(lhs->type)->output;
src/AST/generate_code.cpp:404:      lhs_val = lhs->generate_code();
src/AST/generate_code.cpp:405:      if (out_type->is_struct()) {
src/AST/generate_code.cpp:407:        assert(scope_->is_block_scope());
src/AST/generate_code.cpp:409:            static_cast<BlockScope *>(scope_)->CreateLocalReturn(out_type);
src/AST/generate_code.cpp:419:    if (lhs->type->has_vars) {
src/AST/generate_code.cpp:421:      assert(!fn_lit->cache.empty());
src/AST/generate_code.cpp:423:      for (auto kv : fn_lit->cache) {
src/AST/generate_code.cpp:424:        if (rhs->type == kv.first) {
src/AST/generate_code.cpp:425:          lhs_val = kv.second->generate_code();
src/AST/generate_code.cpp:430:    } else if (lhs->is_identifier()) {
src/AST/generate_code.cpp:432:          scope_, static_cast<Identifier *>(lhs)->token, rhs->type);
src/AST/generate_code.cpp:434:    } else if (lhs->is_function_literal()) {
src/AST/generate_code.cpp:435:      lhs_val = lhs->generate_code();
src/AST/generate_code.cpp:438:      lhs_val = lhs->generate_code();
src/AST/generate_code.cpp:441:    lhs_val = lhs->generate_code();
src/AST/generate_code.cpp:447:// short-circuit.
src/AST/generate_code.cpp:449:  auto lval = lhs->generate_lvalue();                                          \
src/AST/generate_code.cpp:452:  auto parent_fn   = builder.GetInsertBlock()->getParent();                    \
src/AST/generate_code.cpp:458:  auto rhs_val = rhs->generate_code();                                         \
src/AST/generate_code.cpp:476:    Type *to_type = rhs->evaluate(ctx).as_type;
src/AST/generate_code.cpp:477:    if (lhs->type == Bool) {
src/AST/generate_code.cpp:483:    } else if (lhs->type == Int) {
src/AST/generate_code.cpp:489:    } else if (lhs->type == Uint) {
src/AST/generate_code.cpp:495:    } else if (lhs->type->is_pointer() && to_type->is_pointer()) {
src/AST/generate_code.cpp:501:    assert(lhs->type->is_array() && "Type is not an array");
src/AST/generate_code.cpp:502:    auto array_type = (Array *)lhs->type;
src/AST/generate_code.cpp:503:    if (array_type->fixed_length) {
src/AST/generate_code.cpp:505:                                                          rhs->generate_code()},
src/AST/generate_code.cpp:511:          type, builder.CreateGEP(data_ptr, rhs->generate_code(), "array_val"));
src/AST/generate_code.cpp:515:    if (lhs->type->is_function() || lhs->type->is_quantum()) {
src/AST/generate_code.cpp:522:      } else if (type->is_big() && !type->is_function()) {
src/AST/generate_code.cpp:523:        assert(scope_->is_block_scope());
src/AST/generate_code.cpp:526:            static_cast<BlockScope *>(scope_)->CreateLocalReturn(type);
src/AST/generate_code.cpp:540:  auto rhs_val = rhs->generate_code();
src/AST/generate_code.cpp:545:    auto input_type = Tup({lhs->type, rhs->type});                             \
src/AST/generate_code.cpp:550:    auto output_type = static_cast<Function *>(fn_type)->output;               \
src/AST/generate_code.cpp:555:    } else if (output_type->is_big()) {                                        \
src/AST/generate_code.cpp:556:      assert(scope_->is_block_scope());                                        \
src/AST/generate_code.cpp:558:          static_cast<BlockScope *>(scope_)->CreateLocalReturn(output_type);   \
src/AST/generate_code.cpp:567:  if (lhs->type == prim_type && rhs->type == prim_type) {                      \
src/AST/generate_code.cpp:572:  if (lhs->type == prim_type && rhs->type == prim_type) {                      \
src/AST/generate_code.cpp:595:    if (lhs->type->is_function() && rhs->type->is_function()) {
src/AST/generate_code.cpp:596:      auto output_type = Func(static_cast<Function *>(rhs->type)->input,
src/AST/generate_code.cpp:597:                              static_cast<Function *>(lhs->type)->output);
src/AST/generate_code.cpp:615:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:623:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:631:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:639:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:647:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:655:    auto lval = lhs->generate_lvalue();
src/AST/generate_code.cpp:668:  assert(false && "Not valid for code-gen");
src/AST/generate_code.cpp:675:  (*it)->generate_code();
src/AST/generate_code.cpp:679:    auto term_inst = builder.GetInsertBlock()->getTerminator();
src/AST/generate_code.cpp:685:    (*it)->generate_code();
src/AST/generate_code.cpp:694:  auto lhs_val = exprs[0]->generate_code();                                    \
src/AST/generate_code.cpp:697:    auto rhs_val = exprs[i]->generate_code();                                  \
src/AST/generate_code.cpp:700:    switch (ops[i - 1]) {
src/AST/generate_code.cpp:715:    phi->addIncoming(data::const_false(), curr_block);                         \
src/AST/generate_code.cpp:721:    phi->addIncoming(data::const_true(), curr_block);                          \
src/AST/generate_code.cpp:730:  // TODO eval of enums at compile-time is wrong. This could be
src/AST/generate_code.cpp:732:  // 2. That they shouldn't be determined at compile-time
src/AST/generate_code.cpp:738:  auto expr_type = exprs[0]->type;
src/AST/generate_code.cpp:740:  // Boolean values that cannot be short-circuited.
src/AST/generate_code.cpp:744:      llvm::Value *cmp_val = exprs[0]->generate_code();
src/AST/generate_code.cpp:746:        cmp_val = builder.CreateXor(cmp_val, exprs[i]->generate_code());
src/AST/generate_code.cpp:753:      llvm::Value *cmp_val = exprs[0]->generate_code();
src/AST/generate_code.cpp:757:          cmp_val = builder.CreateAnd(cmp_val, exprs[i]->generate_code());
src/AST/generate_code.cpp:760:          cmp_val = builder.CreateAnd(cmp_val, exprs[i]->generate_code());
src/AST/generate_code.cpp:762:        default: assert(false && "Invalid chain-operation on bools");
src/AST/generate_code.cpp:768:  auto parent_fn  = builder.GetInsertBlock()->getParent();
src/AST/generate_code.cpp:817:  } else if (expr_type->is_enum() || expr_type->is_pointer()) {
src/AST/generate_code.cpp:823:  } else if (expr_type->is_struct()) {
src/AST/generate_code.cpp:830:                                Tup({exprs[i - 1]->type, exprs[i]->type}));    \
src/AST/generate_code.cpp:854:        builder.CreateCondBr(ex->generate_code(), next_block, landing);
src/AST/generate_code.cpp:855:        phi->addIncoming(data::const_false(), builder.GetInsertBlock());
src/AST/generate_code.cpp:860:      phi->addIncoming(data::const_true(), curr_block);
src/AST/generate_code.cpp:866:        builder.CreateCondBr(ex->generate_code(), landing, next_block);
src/AST/generate_code.cpp:867:        phi->addIncoming(data::const_true(), builder.GetInsertBlock());
src/AST/generate_code.cpp:872:      phi->addIncoming(data::const_false(), curr_block);
src/AST/generate_code.cpp:875:      assert(false && "invalid operand in short-circuiting");
src/AST/generate_code.cpp:895:    assert(type->is_function() && "How is the type not a function?");
src/AST/generate_code.cpp:898:    if (fn_type->time() == Time::compile) return nullptr;
src/AST/generate_code.cpp:902:        static_cast<llvm::FunctionType *>(type->llvm_type),
src/AST/generate_code.cpp:907:  auto arg_iter = llvm_fn->args().begin();
src/AST/generate_code.cpp:909:    arg_iter->setName(input_iter->identifier->token);
src/AST/generate_code.cpp:911:    auto decl_id   = input_iter->identifier;
src/AST/generate_code.cpp:912:    auto decl_type = decl_id->type;
src/AST/generate_code.cpp:913:    if (decl_type->is_big()) { decl_id->alloc = arg_iter; }
src/AST/generate_code.cpp:919:  auto ret_type = return_type_expr->evaluate(ctx).as_type;
src/AST/generate_code.cpp:920:  if (ret_type->is_struct()) { arg_iter->setName("retval"); }
src/AST/generate_code.cpp:922:  fn_scope->set_parent_function(llvm_fn);
src/AST/generate_code.cpp:923:  fn_scope->fn_type = (Function *)type;
src/AST/generate_code.cpp:926:  builder.SetInsertPoint(fn_scope->entry);
src/AST/generate_code.cpp:929:  fn_scope->initialize();
src/AST/generate_code.cpp:931:  auto arg = llvm_fn->args().begin();
src/AST/generate_code.cpp:933:    auto decl_id = input_iter->identifier;
src/AST/generate_code.cpp:935:    if (!decl_id->type->is_big()) {
src/AST/generate_code.cpp:936:      Type::CallAssignment(scope_, decl_id->type, decl_id->type,
src/AST/generate_code.cpp:937:                           input_iter->identifier->alloc, arg);
src/AST/generate_code.cpp:943:  statements->generate_code();
src/AST/generate_code.cpp:945:  if (block->empty() || !llvm::isa<llvm::BranchInst>(&block->back())) {
src/AST/generate_code.cpp:946:    builder.CreateBr(fn_scope->exit);
src/AST/generate_code.cpp:949:  fn_scope->leave();
src/AST/generate_code.cpp:955:  assert(type->is_function());
src/AST/generate_code.cpp:957:  llvm_fn->setName(Mangle((Function *)type, this));
src/AST/generate_code.cpp:969:  if (IsCustomInitialized() && type->is_function()) {
src/AST/generate_code.cpp:971:    auto llvm_fn_type = (llvm::FunctionType *)fn_type->llvm_type;
src/AST/generate_code.cpp:974:    if (init_val->is_function_literal()) {
src/AST/generate_code.cpp:976:      func->fn_scope->name = identifier->token;
src/AST/generate_code.cpp:978:      func->llvm_fn = (llvm::Function *)global_module->getOrInsertFunction(
src/AST/generate_code.cpp:981:    } else if (init_val->is_binop()) {
src/AST/generate_code.cpp:982:      assert(((Binop *)init_val)->op == Language::Operator::Mul);
src/AST/generate_code.cpp:984:      auto lhs_val = binop->lhs->generate_code();
src/AST/generate_code.cpp:985:      auto rhs_val = binop->rhs->generate_code();
src/AST/generate_code.cpp:990:    llvm::Value *val = init_val->generate_code();
src/AST/generate_code.cpp:992:    val->setName(mangled_name);
src/AST/generate_code.cpp:995:    llvm::Value *var = identifier->generate_lvalue();
src/AST/generate_code.cpp:996:    llvm::Value *val = init_val->generate_code();
src/AST/generate_code.cpp:1000:    Type::CallAssignment(scope_, identifier->type, init_val->type, var, val);
src/AST/generate_code.cpp:1008:  auto parent_fn      = builder.GetInsertBlock()->getParent();
src/AST/generate_code.cpp:1009:  // Condition blocks - The ith block is what you reach when you've
src/AST/generate_code.cpp:1011:  std::vector<llvm::BasicBlock *> case_blocks(num_key_vals - 1);
src/AST/generate_code.cpp:1023:      builder.CreatePHI(*(type->is_big() ? Ptr(type) : type),
src/AST/generate_code.cpp:1028:    auto cmp_val    = key_vals[i].first->generate_code();
src/AST/generate_code.cpp:1034:    auto output_val = key_vals[i].second->generate_code();
src/AST/generate_code.cpp:1037:    // block 'true_block'. However, if the code generated for the right-hand
src/AST/generate_code.cpp:1040:    phi_node->addIncoming(output_val, builder.GetInsertBlock());
src/AST/generate_code.cpp:1046:  auto output_val = key_vals.back().second->generate_code();
src/AST/generate_code.cpp:1048:  phi_node->addIncoming(output_val, builder.GetInsertBlock());
src/AST/generate_code.cpp:1060:  auto element_type  = type_as_array->data_type;
src/AST/generate_code.cpp:1064:  assert(CurrentScope()->is_block_scope());
src/AST/generate_code.cpp:1066:  auto entry_block = curr_scope->is_function_scope()
src/AST/generate_code.cpp:1067:                         ? curr_scope->entry
src/AST/generate_code.cpp:1068:                         : curr_scope->containing_function_->entry;
src/AST/generate_code.cpp:1070:  builder.SetInsertPoint(entry_block->begin());
src/AST/generate_code.cpp:1072:  // free-ing it is safe.
src/AST/generate_code.cpp:1074:  auto array_data = type->allocate();
src/AST/generate_code.cpp:1075:  type->call_init(array_data);
src/AST/generate_code.cpp:1079:  assert(type_as_array->fixed_length);
src/AST/generate_code.cpp:1088:    if (!element_type->is_primitive()) { element_type->call_init(data_ptr); }
src/AST/generate_code.cpp:1091:                         elems[i]->generate_code());
src/AST/generate_code.cpp:1094:  assert(scope_->is_block_scope());
src/AST/generate_code.cpp:1095:  static_cast<BlockScope *>(scope_)->defer_uninit(type, array_data);
src/AST/generate_code.cpp:1103:  auto parent_fn = builder.GetInsertBlock()->getParent();
src/AST/generate_code.cpp:1104:  for (auto s : body_scopes) { s->set_parent_function(parent_fn); }
src/AST/generate_code.cpp:1121:  for (size_t i = 0; i < conditions.size() - 1; ++i) {
src/AST/generate_code.cpp:1123:    auto condition = conditions[i]->generate_code();
src/AST/generate_code.cpp:1124:    builder.CreateCondBr(condition, body_scopes[i]->entry, cond_block[i + 1]);
src/AST/generate_code.cpp:1129:  auto condition = conditions.back()->generate_code();
src/AST/generate_code.cpp:1130:  builder.CreateCondBr(condition, body_scopes[conditions.size() - 1]->entry,
src/AST/generate_code.cpp:1131:                       has_else() ? body_scopes.back()->entry : land_block);
src/AST/generate_code.cpp:1135:    assert(!body_scopes[i]->land);
src/AST/generate_code.cpp:1136:    body_scopes[i]->land = land_block;
src/AST/generate_code.cpp:1139:    body_scopes[i]->initialize();
src/AST/generate_code.cpp:1143:    statements[i]->generate_code();
src/AST/generate_code.cpp:1145:    auto term_inst = builder.GetInsertBlock()->getTerminator();
src/AST/generate_code.cpp:1146:    if (!term_inst) { builder.CreateBr(body_scopes[i]->exit); }
src/AST/generate_code.cpp:1148:    builder.SetInsertPoint(body_scopes[i]->exit);
src/AST/generate_code.cpp:1149:    body_scopes[i]->uninitialize();
src/AST/generate_code.cpp:1152:        builder.CreateLoad(body_scopes[i]->containing_function_->ExitFlag());
src/AST/generate_code.cpp:1154:    assert(body_scopes[i]->parent->is_block_scope());
src/AST/generate_code.cpp:1155:    auto parent_block_scope = static_cast<BlockScope *>(body_scopes[i]->parent);
src/AST/generate_code.cpp:1157:    builder.CreateCondBr(is_zero, land_block, parent_block_scope->exit);
src/AST/generate_code.cpp:1172:  if (CurrentScope()->is_function_scope()) {
src/AST/generate_code.cpp:1175:      builder.CreateBr(static_cast<BlockScope *>(CurrentScope())->exit);
src/AST/generate_code.cpp:1179:      exit_flag_alloc = static_cast<FnScope *>(CurrentScope())->ExitFlag();
src/AST/generate_code.cpp:1183:    exit_flag_alloc = CurrentScope()->containing_function_->ExitFlag();
src/AST/generate_code.cpp:1204:  builder.CreateBr(static_cast<BlockScope *>(CurrentScope())->exit);
src/AST/generate_code.cpp:1210:  auto parent_fn = builder.GetInsertBlock()->getParent();
src/AST/generate_code.cpp:1211:  while_scope->set_parent_function(parent_fn);
src/AST/generate_code.cpp:1213:  assert(!while_scope->land);
src/AST/generate_code.cpp:1216:  while_scope->land = make_block("while.land", parent_fn);
src/AST/generate_code.cpp:1222:  auto cond = condition->generate_code();
src/AST/generate_code.cpp:1224:  builder.CreateCondBr(cond, while_scope->entry, while_scope->land);
src/AST/generate_code.cpp:1227:  while_scope->initialize();
src/AST/generate_code.cpp:1231:  statements->generate_code();
src/AST/generate_code.cpp:1232:  builder.CreateBr(while_scope->exit);
src/AST/generate_code.cpp:1234:  builder.SetInsertPoint(while_scope->exit);
src/AST/generate_code.cpp:1235:  while_scope->uninitialize();
src/AST/generate_code.cpp:1238:      builder.CreateLoad(while_scope->containing_function_->ExitFlag());
src/AST/generate_code.cpp:1242:  switch_stmt->addCase(BREAK_FLAG, while_scope->land);
src/AST/generate_code.cpp:1244:  assert(while_scope->parent->is_block_scope());
src/AST/generate_code.cpp:1246:  switch_stmt->addCase(RETURN_FLAG, parent_block_scope->exit);
src/AST/generate_code.cpp:1250:  builder.SetInsertPoint(while_scope->land);
src/AST/generate_code.cpp:1259:  auto parent_fn = start_block->getParent();
src/AST/generate_code.cpp:1260:  for_scope->set_parent_function(parent_fn);
src/AST/generate_code.cpp:1268:  assert(!for_scope->land);
src/AST/generate_code.cpp:1269:  for_scope->land = make_block("loop.land", parent_fn);
src/AST/generate_code.cpp:1281:    if (!iter->identifier->alloc) {
src/AST/generate_code.cpp:1282:      assert(iter->scope_->is_block_scope());
src/AST/generate_code.cpp:1283:      auto block_scope = (BlockScope *)(iter->scope_);
src/AST/generate_code.cpp:1284:      iter->identifier->alloc = block_scope->AllocateLocally(
src/AST/generate_code.cpp:1285:          iter->identifier->type, iter->identifier->token);
src/AST/generate_code.cpp:1287:    auto container = iter->container;
src/AST/generate_code.cpp:1290:    if (container->type->is_slice()) {
src/AST/generate_code.cpp:1294:      // TODO assume slices aren't first-class types and only defined literally
src/AST/generate_code.cpp:1296:      assert(container->is_binop());
src/AST/generate_code.cpp:1299:      assert(container_as_binop->op == Language::Operator::Index &&
src/AST/generate_code.cpp:1300:             container_as_binop->lhs->type->is_array());
src/AST/generate_code.cpp:1302:      assert(container_as_binop->rhs->type->is_range());
src/AST/generate_code.cpp:1304:      auto array      = container_as_binop->lhs;
src/AST/generate_code.cpp:1305:      auto array_val  = array->generate_code();
src/AST/generate_code.cpp:1306:      auto array_type = static_cast<Array *>(array->type);
src/AST/generate_code.cpp:1308:      auto range      = container_as_binop->rhs;
src/AST/generate_code.cpp:1310:      if (container_as_binop->rhs->is_binop()) {
src/AST/generate_code.cpp:1311:        start_num = static_cast<Binop *>(range)->lhs->generate_code();
src/AST/generate_code.cpp:1312:        end_num   = static_cast<Binop *>(range)->rhs->generate_code();
src/AST/generate_code.cpp:1314:        assert(container_as_binop->rhs->is_unop());
src/AST/generate_code.cpp:1316:        assert(range_as_unop->op == Language::Operator::Dots);
src/AST/generate_code.cpp:1317:        start_num = range_as_unop->operand->generate_code();
src/AST/generate_code.cpp:1319:        if (array_type->fixed_length) {
src/AST/generate_code.cpp:1320:          end_num = data::const_uint(array_type->len);
src/AST/generate_code.cpp:1334:          (array_type->fixed_length)
src/AST/generate_code.cpp:1346:      phi = builder.CreatePHI(*Ptr(iter->type), 2, "phi");
src/AST/generate_code.cpp:1347:      phi->addIncoming(start_ptr, init_iters);
src/AST/generate_code.cpp:1351:      iter->identifier->alloc = phi;
src/AST/generate_code.cpp:1357:      phi->addIncoming(next, incr_iters);
src/AST/generate_code.cpp:1359:    } else if (container->type->is_array()) {
src/AST/generate_code.cpp:1362:      auto container_val = container->generate_code();
src/AST/generate_code.cpp:1367:      auto array_type = (Array *)container->type;
src/AST/generate_code.cpp:1368:      if (array_type->fixed_length) {
src/AST/generate_code.cpp:1373:            start_ptr, data::const_uint(array_type->len), "end_ptr");
src/AST/generate_code.cpp:1389:      phi = builder.CreatePHI(*Ptr(iter->type), 2, "phi");
src/AST/generate_code.cpp:1390:      phi->addIncoming(start_ptr, init_iters);
src/AST/generate_code.cpp:1394:      iter->identifier->alloc = phi;
src/AST/generate_code.cpp:1400:      phi->addIncoming(next, incr_iters);
src/AST/generate_code.cpp:1402:    } else if (container->type->is_range()) {
src/AST/generate_code.cpp:1403:      if (container->is_binop()) {
src/AST/generate_code.cpp:1404:        assert(static_cast<Binop *>(container)->op == Language::Operator::Dots);
src/AST/generate_code.cpp:1409:            static_cast<Binop *>(container)->lhs->generate_code();
src/AST/generate_code.cpp:1411:            static_cast<Binop *>(container)->rhs->generate_code();
src/AST/generate_code.cpp:1415:        phi = builder.CreatePHI(*iter->type, 2, "phi");
src/AST/generate_code.cpp:1416:        phi->addIncoming(start_val, init_iters);
src/AST/generate_code.cpp:1420:        builder.CreateStore(phi, iter->identifier->alloc);
src/AST/generate_code.cpp:1422:                                    (iter->type == Int)
src/AST/generate_code.cpp:1427:      } else if (container->is_unop()) {
src/AST/generate_code.cpp:1428:        assert(static_cast<Unop *>(container)->op == Language::Operator::Dots);
src/AST/generate_code.cpp:1433:            static_cast<Unop *>(container)->operand->generate_code();
src/AST/generate_code.cpp:1437:        phi = builder.CreatePHI(*iter->type, 2, "phi");
src/AST/generate_code.cpp:1438:        phi->addIncoming(start_val, init_iters);
src/AST/generate_code.cpp:1442:        builder.CreateStore(phi, iter->identifier->alloc);
src/AST/generate_code.cpp:1451:          builder.CreateLoad(iter->identifier->alloc),
src/AST/generate_code.cpp:1452:          iter->type == Char ? data::const_char(1) : data::const_uint(1));
src/AST/generate_code.cpp:1453:      phi->addIncoming(next, incr_iters);
src/AST/generate_code.cpp:1456:      auto ty = container->evaluate(ctx).as_type;
src/AST/generate_code.cpp:1457:      assert(ty->is_enum());
src/AST/generate_code.cpp:1466:      phi->addIncoming(data::const_uint(0), init_iters);
src/AST/generate_code.cpp:1472:                        phi, data::const_uint(enum_type->int_values.size())));
src/AST/generate_code.cpp:1473:      builder.CreateStore(phi, iter->identifier->alloc);
src/AST/generate_code.cpp:1477:      auto next = builder.CreateAdd(builder.CreateLoad(iter->identifier->alloc),
src/AST/generate_code.cpp:1479:      phi->addIncoming(next, incr_iters);
src/AST/generate_code.cpp:1494:  builder.CreateCondBr(done_cmp, for_scope->land, for_scope->entry);
src/AST/generate_code.cpp:1500:  for_scope->initialize();
src/AST/generate_code.cpp:1504:  statements->generate_code();
src/AST/generate_code.cpp:1505:  builder.CreateBr(for_scope->exit);
src/AST/generate_code.cpp:1507:  for_scope->uninitialize();
src/AST/generate_code.cpp:1510:      builder.CreateLoad(for_scope->containing_function_->ExitFlag());
src/AST/generate_code.cpp:1515:  switch_stmt->addCase(RESTART_FLAG, init_iters);
src/AST/generate_code.cpp:1516:  switch_stmt->addCase(REPEAT_FLAG, for_scope->entry);
src/AST/generate_code.cpp:1517:  switch_stmt->addCase(BREAK_FLAG, for_scope->land);
src/AST/generate_code.cpp:1518:  assert(for_scope->parent->is_block_scope());
src/AST/generate_code.cpp:1519:  auto parent_block_scope = static_cast<BlockScope *>(for_scope->parent);
src/AST/generate_code.cpp:1520:  switch_stmt->addCase(RETURN_FLAG, parent_block_scope->exit);
src/AST/generate_code.cpp:1524:  builder.SetInsertPoint(for_scope->land);
src/AST/generate_lvalue.cpp:16:  if (op == Language::Operator::At) { return operand->generate_code(); }
src/AST/generate_lvalue.cpp:38:  auto etype  = operand->type;
src/AST/generate_lvalue.cpp:39:  auto e_lval = operand->generate_lvalue();
src/AST/generate_lvalue.cpp:41:  while (etype->is_pointer()) {
src/AST/generate_lvalue.cpp:42:    etype  = static_cast<Pointer *>(etype)->pointee;
src/AST/generate_lvalue.cpp:48:      e_lval, {data::const_uint(0), struct_type->field_num(member_name)});
src/AST/generate_lvalue.cpp:52:  if (op == Language::Operator::Index && lhs->type->is_array()) {
src/AST/generate_lvalue.cpp:53:    auto array_type = (Array*)lhs->type;
src/AST/generate_lvalue.cpp:54:    auto lhs_val  = lhs->generate_lvalue();
src/AST/generate_lvalue.cpp:55:    auto rhs_val  = rhs->generate_code();
src/AST/generate_lvalue.cpp:56:    if (array_type->fixed_length) {
src/AST/get_global.cpp:43:  assert(type->is_array());
src/AST/get_global.cpp:45:  assert(array_type->fixed_length);
src/AST/get_global.cpp:47:  std::vector<llvm::Constant *> constants(array_type->len, nullptr);
src/AST/get_global.cpp:49:  for (size_t i = 0; i < array_type->len; ++i) {
src/AST/get_global.cpp:50:    constants[i] = elems[i]->GetGlobal();
src/AST/get_global.cpp:54:      static_cast<llvm::ArrayType *>(array_type->llvm_type), constants);
src/AST/get_global.cpp:65:    return operand->GetGlobal();
src/AST/lrval.cpp:9:  operand->lrvalue_check();
src/AST/lrval.cpp:11:    if (!operand->lvalue && operand->type != Type_) {
src/AST/lrval.cpp:16:           operand->lvalue;
src/AST/lrval.cpp:20:  operand->lrvalue_check();
src/AST/lrval.cpp:21:  if (operand->type == Type_ &&
src/AST/lrval.cpp:24:  } else if (operand->type->is_array() &&
src/AST/lrval.cpp:25:             static_cast<Array *>(operand->type)->fixed_length &&
src/AST/lrval.cpp:29:    lvalue = operand->lvalue;
src/AST/lrval.cpp:34:  lhs->lrvalue_check();
src/AST/lrval.cpp:35:  if (rhs) { rhs->lrvalue_check(); }
src/AST/lrval.cpp:37:  if (is_assignment() && !lhs->lvalue) {
src/AST/lrval.cpp:44:        lhs->lvalue;
src/AST/lrval.cpp:50:  for (auto e : exprs) { e->lrvalue_check(); }
src/AST/lrval.cpp:55:  return_type_expr->lrvalue_check();
src/AST/lrval.cpp:58:    in->lrvalue_check();
src/AST/lrval.cpp:59:    input_has_vars |= in->type->has_vars;
src/AST/lrval.cpp:62:  if (!input_has_vars) { statements->lrvalue_check(); }
src/AST/lrval.cpp:67:  identifier->lrvalue_check();
src/AST/lrval.cpp:68:  test_fn->lrvalue_check();
src/AST/lrval.cpp:73:  identifier->lrvalue_check();
src/AST/lrval.cpp:74:  container->lrvalue_check();
src/AST/lrval.cpp:79:  identifier->lrvalue_check();
src/AST/lrval.cpp:80:  if (type_expr) { type_expr->lrvalue_check(); }
src/AST/lrval.cpp:81:  if (init_val) { init_val->lrvalue_check(); }
src/AST/lrval.cpp:85:  if (length) { length->lrvalue_check(); }
src/AST/lrval.cpp:86:  data_type->lrvalue_check();
src/AST/lrval.cpp:92:    e->lrvalue_check();
src/AST/lrval.cpp:99:    kv.first->lrvalue_check();
src/AST/lrval.cpp:100:    kv.second->lrvalue_check();
src/AST/lrval.cpp:106:    stmt->lrvalue_check();
src/AST/lrval.cpp:113:  for (auto cond : conditions) { cond->lrvalue_check(); }
src/AST/lrval.cpp:114:  for (auto stmt : statements) { stmt->lrvalue_check(); }
src/AST/lrval.cpp:119:  statements->lrvalue_check();
src/AST/lrval.cpp:120:  for (auto decl : iterators) { decl->lrvalue_check(); }
src/AST/lrval.cpp:124:  condition->lrvalue_check();
src/AST/lrval.cpp:125:  statements->lrvalue_check();
src/AST/time.cpp:7:  time_ = operand->determine_time();
src/AST/time.cpp:16:  if (type->is_enum()) { return time_ = Time::either; }
src/AST/time.cpp:17:  return time_ = operand->determine_time();
src/AST/time.cpp:22:    return time_ = lhs->determine_time();
src/AST/time.cpp:25:    if (lhs->type->is_parametric_struct()) {
src/AST/time.cpp:26:      assert(type->is_struct());
src/AST/time.cpp:28:                         ->ast_expression->determine_time();
src/AST/time.cpp:31:    return time_ = rhs ? rhs->determine_time() : Time::either;
src/AST/time.cpp:35:  return time_ = lhs->determine_time() | rhs->determine_time();
src/AST/time.cpp:40:  for (const auto &expr : exprs) { time_ |= expr->determine_time(); }
src/AST/time.cpp:44:Time::Eval ArrayLiteral::determine_time() { return time_ = type->time(); }
src/AST/time.cpp:47:  length->determine_time();
src/AST/time.cpp:48:  data_type->determine_time();
src/AST/time.cpp:57:Time::Eval Identifier::determine_time() { return time_ = type->time(); }
src/AST/time.cpp:61:  test_fn->determine_time();
src/AST/time.cpp:62:  return time_ = identifier->determine_time();
src/AST/time.cpp:66:  container->determine_time();
src/AST/time.cpp:67:  return time_ = identifier->determine_time();
src/AST/time.cpp:71:  if (type_expr) { type_expr->determine_time(); }
src/AST/time.cpp:72:  if (init_val) { init_val->determine_time(); }
src/AST/time.cpp:73:  return time_ = identifier->determine_time();
src/AST/time.cpp:79:    time_ |= kv.first->determine_time();
src/AST/time.cpp:80:    time_ |= kv.second->determine_time();
src/AST/time.cpp:86:  for (auto &stmt : statements) { time_ |= stmt->determine_time(); }
src/AST/time.cpp:94:    input_has_vars |= in->type->has_vars;
src/AST/time.cpp:95:    time_ |= in->determine_time();
src/AST/time.cpp:101:    return (time_ |= statements->determine_time());
src/AST/time.cpp:107:  for (auto &cond : conditions) { time_ |= cond->determine_time(); }
src/AST/time.cpp:108:  for (auto &stmt : statements) { time_ |= stmt->determine_time(); }
src/AST/time.cpp:114:  return time_ = condition->determine_time() | statements->determine_time();
src/AST/time.cpp:118:  time_ = statements->determine_time();
src/AST/time.cpp:119:  for (auto iter : iterators) { time_ |= iter->determine_time(); }
src/AST/time.cpp:129:  for (auto d : decls) { time_ |= d->determine_time(); }
src/AST/to_string.cpp:5:#define TYPE_OR(other) (type ? type->to_string() : (other))
src/AST/to_string.cpp:23:       << conditions[i]->to_string(n + 1) << statements[i]->to_string(n + 1);
src/AST/to_string.cpp:27:    ss << tabs(n + 1) << "Else:\n" << statements.back()->to_string(n + 1);
src/AST/to_string.cpp:35:  for (const auto &el : elems) { output += el->to_string(n + 1); }
src/AST/to_string.cpp:41:  return tabs(n) + "<While>\n" + condition->to_string(n + 1) +
src/AST/to_string.cpp:42:         statements->to_string(n + 1);
src/AST/to_string.cpp:48:  for (auto iter : iterators) { ss << iter->to_string(n + 1); }
src/AST/to_string.cpp:49:  ss << statements->to_string(n + 1);
src/AST/to_string.cpp:73:  ss << ">\n" << operand->to_string(n + 1);
src/AST/to_string.cpp:79:         operand->to_string(n + 1);
src/AST/to_string.cpp:92:    case Language::Operator::Arrow: ss << "->"; break;
src/AST/to_string.cpp:110:  ss << ">\n" << lhs->to_string(n + 1) << (rhs ? rhs->to_string(n + 1) : tabs(n + 1) + "0x0\n");
src/AST/to_string.cpp:117:  return output + length->to_string(n + 1) + data_type->to_string(n + 1);
src/AST/to_string.cpp:126:  for (const auto &expr : exprs) { output += expr->to_string(n + 1); }
src/AST/to_string.cpp:140:  case Language::Terminal::Hole: ss << "--"; break;
src/AST/to_string.cpp:163:  return tabs(n) + "<"+ identifier->token + "`>\n" + test_fn->to_string(n + 1);
src/AST/to_string.cpp:167:  return tabs(n) + "<"+ identifier->token + " in>\n" + container->to_string(n + 1);
src/AST/to_string.cpp:173:     << TYPE_OR("") << ">\n" << identifier->to_string(n + 1);
src/AST/to_string.cpp:175:  if (type_expr) { ss << "Type: " << type_expr->to_string(n + 1); }
src/AST/to_string.cpp:176:  if (init_val) { ss << "Init: " << init_val->to_string(n + 1); }
src/AST/to_string.cpp:190:       << std::to_string(num_key_vals) << "]\n" << kv.first->to_string(n + 1)
src/AST/to_string.cpp:191:       << kv.second->to_string(n + 1);
src/AST/to_string.cpp:199:  for (const auto &exprs : statements) { output += exprs->to_string(n + 1); }
src/AST/to_string.cpp:207:  for (const auto &kv : inputs) { ss << kv->to_string(n + 1); }
src/AST/to_string.cpp:208:  ss << return_type_expr->to_string(n + 1) << tabs(n + 1) << "Body:\n"
src/AST/to_string.cpp:209:     << statements->to_string(n + 2);
src/AST/to_string.cpp:217:    ss << tabs(n + 1) << d->identifier->token << "\n";
src/AST/to_string.cpp:226:    ss << tabs(n + 1) << d->identifier->token << "\n";
src/AST/to_string.cpp:249:  return tabs(n) + "<" + value.as_type->to_string() + ">\n";
src/AST/verify_types.cpp:28:  auto cloned_func = (AST::FunctionLiteral *)fn_lit->clone(
src/AST/verify_types.cpp:32:  Scope::Stack.push(fn_lit->scope_);
src/AST/verify_types.cpp:34:  cloned_func->assign_scope();
src/AST/verify_types.cpp:35:  cloned_func->verify_types();
src/AST/verify_types.cpp:50:// This function is handed two types. The left-hand side argument is the input
src/AST/verify_types.cpp:51:// to a function, and the right-hand side argument is the arguments a function
src/AST/verify_types.cpp:67:// of a value, or if we provided an array with a run-time length instead of a
src/AST/verify_types.cpp:68:// fixed-length array.
src/AST/verify_types.cpp:77:  if (!lhs->has_vars) {
src/AST/verify_types.cpp:80:        rhs->to_string() + " does not match " + lhs->to_string() + ".\n";
src/AST/verify_types.cpp:84:  if (lhs->is_type_variable()) {
src/AST/verify_types.cpp:86:    assert(lhs_var->test);
src/AST/verify_types.cpp:89:    auto test_fn_expr = lhs_var->test->evaluate(ctx).as_expr;
src/AST/verify_types.cpp:90:    assert(test_fn_expr->is_function_literal());
src/AST/verify_types.cpp:94:    assert(test_fn->type == Func(Type_, Bool));
src/AST/verify_types.cpp:98:    auto f = test_fn->EmitIR();
src/AST/verify_types.cpp:110:      } else if (iter->second == rhs) {
src/AST/verify_types.cpp:116:            "Failure to match parameter " + lhs_var->to_string() + ".\n";
src/AST/verify_types.cpp:121:      error_message += "Type " + rhs->to_string() + " failed test for " +
src/AST/verify_types.cpp:122:                       lhs_var->identifier->token + ".";
src/AST/verify_types.cpp:124:      if (lhs_var->test->is_identifier()) {
src/AST/verify_types.cpp:125:        auto id_test = (AST::Identifier *)(lhs_var->test);
src/AST/verify_types.cpp:127:                         std::to_string(id_test->decl->loc.line_num) + ")";
src/AST/verify_types.cpp:134:  if (lhs->is_pointer()) {
src/AST/verify_types.cpp:135:    if (!rhs->is_pointer()) {
src/AST/verify_types.cpp:137:          "Expected pointer, but received " + rhs->to_string() + ".\n";
src/AST/verify_types.cpp:141:    return MatchCall(static_cast<Pointer *>(lhs)->pointee,
src/AST/verify_types.cpp:142:                     static_cast<Pointer *>(rhs)->pointee, matches,
src/AST/verify_types.cpp:146:  if (lhs->is_array()) {
src/AST/verify_types.cpp:147:    if (!rhs->is_array()) {
src/AST/verify_types.cpp:148:      error_message += "Expected array, but received" + rhs->to_string() + ".\n";
src/AST/verify_types.cpp:155:    if (lhs_array->fixed_length != rhs_array->fixed_length) { return false; }
src/AST/verify_types.cpp:157:    if (lhs_array->fixed_length) {
src/AST/verify_types.cpp:158:      return (lhs_array->len == rhs_array->len) &&
src/AST/verify_types.cpp:159:             MatchCall(lhs_array->data_type, rhs_array->data_type, matches,
src/AST/verify_types.cpp:162:      return MatchCall(lhs_array->data_type, rhs_array->data_type, matches,
src/AST/verify_types.cpp:167:  if (lhs->is_function()) {
src/AST/verify_types.cpp:168:    if (!rhs->is_function()) {
src/AST/verify_types.cpp:170:          "Expected function, but received" + rhs->to_string() + ".\n";
src/AST/verify_types.cpp:174:    auto lhs_in  = static_cast<Function *>(lhs)->input;
src/AST/verify_types.cpp:175:    auto rhs_in  = static_cast<Function *>(rhs)->input;
src/AST/verify_types.cpp:176:    auto lhs_out = static_cast<Function *>(lhs)->output;
src/AST/verify_types.cpp:177:    auto rhs_out = static_cast<Function *>(rhs)->output;
src/AST/verify_types.cpp:183:  if (lhs->is_struct()) {
src/AST/verify_types.cpp:184:    if (!rhs->is_struct()) { return false; }
src/AST/verify_types.cpp:191:    if (lhs_struct->creator != rhs_struct->creator) { return false; }
src/AST/verify_types.cpp:194:        lhs_struct->creator->reverse_cache[lhs_struct->ast_expression];
src/AST/verify_types.cpp:196:        rhs_struct->creator->reverse_cache[rhs_struct->ast_expression];
src/AST/verify_types.cpp:212:  if (lhs->is_tuple()) {
src/AST/verify_types.cpp:215:    if (lhs_tuple->entries.size() != rhs_tuple->entries.size()) {
src/AST/verify_types.cpp:219:    size_t num_entries = lhs_tuple->entries.size();
src/AST/verify_types.cpp:222:      if (!MatchCall(lhs_tuple->entries[i], rhs_tuple->entries[i], matches,
src/AST/verify_types.cpp:235:  if (!type->has_vars) { return type; }
src/AST/verify_types.cpp:237:  if (type->is_type_variable()) {
src/AST/verify_types.cpp:239:    return (iter == lookup.end()) ? type : iter->second;
src/AST/verify_types.cpp:242:  if (type->is_pointer()) {
src/AST/verify_types.cpp:244:    return Ptr(EvalWithVars(ptr_type->pointee, lookup));
src/AST/verify_types.cpp:247:  if (type->is_array()) {
src/AST/verify_types.cpp:249:    if (array_type->fixed_length) {
src/AST/verify_types.cpp:250:      return Arr(EvalWithVars(array_type->data_type, lookup), array_type->len);
src/AST/verify_types.cpp:252:      return Arr(EvalWithVars(array_type->data_type, lookup));
src/AST/verify_types.cpp:256:  if (type->is_function()) {
src/AST/verify_types.cpp:258:    return Func(EvalWithVars(func_type->input, lookup),
src/AST/verify_types.cpp:259:                EvalWithVars(func_type->output, lookup));
src/AST/verify_types.cpp:262:  if (type->is_tuple()) {
src/AST/verify_types.cpp:265:    entries.reserve(tup_type->entries.size());
src/AST/verify_types.cpp:267:    for (auto entry : tup_type->entries) {
src/AST/verify_types.cpp:274:  if (type->is_struct()) {
src/AST/verify_types.cpp:276:    assert(struct_type->creator);
src/AST/verify_types.cpp:278:        struct_type->creator->reverse_cache.find(struct_type->ast_expression) !=
src/AST/verify_types.cpp:279:        struct_type->creator->reverse_cache.end());
src/AST/verify_types.cpp:282:        struct_type->creator->reverse_cache[struct_type->ast_expression];
src/AST/verify_types.cpp:292:    return struct_type->creator->CreateOrGetCached(evaled_params).as_type;
src/AST/verify_types.cpp:309:  assert(value.as_type && value.as_type->is_struct());
src/AST/verify_types.cpp:312:  if (!tval->field_num_to_name.empty()) { return; }
src/AST/verify_types.cpp:315:    decls[i]->verify_types();
src/AST/verify_types.cpp:318:    tval->insert_field(decls[i]->identifier->token,
src/AST/verify_types.cpp:319:                       decls[i]->type_expr
src/AST/verify_types.cpp:320:                           ? decls[i]->type_expr->evaluate(ctx).as_type
src/AST/verify_types.cpp:321:                           : decls[i]->init_val->type,
src/AST/verify_types.cpp:322:                       decls[i]->init_val);
src/AST/verify_types.cpp:330:    auto string_decl = Scope::Global->IdentifierHereOrNull("string");
src/AST/verify_types.cpp:331:    string_decl->verify_types();
src/AST/verify_types.cpp:341:  for (auto scope_ptr = scope_; scope_ptr; scope_ptr = scope_ptr->parent) {
src/AST/verify_types.cpp:342:    for (auto d : scope_ptr->DeclRegistry) {
src/AST/verify_types.cpp:343:      if (token != d->identifier->token) { continue; }
src/AST/verify_types.cpp:361:  type = decl->type;
src/AST/verify_types.cpp:366:  operand->verify_types();
src/AST/verify_types.cpp:367:  if (operand->type == Error) {
src/AST/verify_types.cpp:375:    if (!operand->type->is_pointer()) {
src/AST/verify_types.cpp:381:    if (operand->type == Void) {
src/AST/verify_types.cpp:387:    if (operand->type == Void) {
src/AST/verify_types.cpp:394:    if (operand->type->is_pointer()) {
src/AST/verify_types.cpp:395:      type = static_cast<Pointer *>(operand->type)->pointee;
src/AST/verify_types.cpp:399:                             operand->type->to_string() +
src/AST/verify_types.cpp:405:    type = (operand->type == Type_) ? Type_ : Ptr(operand->type);
src/AST/verify_types.cpp:409:    if (operand->type == Uint) {
src/AST/verify_types.cpp:413:    } else if (operand->type == Int) {
src/AST/verify_types.cpp:416:    } else if (operand->type == Real) {
src/AST/verify_types.cpp:419:    } else if (operand->type->is_struct()) {
src/AST/verify_types.cpp:420:      for (auto scope_ptr = scope_; scope_ptr; scope_ptr = scope_ptr->parent) {
src/AST/verify_types.cpp:421:        auto id_ptr = scope_ptr->IdentifierHereOrNull("__neg__");
src/AST/verify_types.cpp:424:        id_ptr->verify_types();
src/AST/verify_types.cpp:427:      auto t = GetFunctionTypeReferencedIn(scope_, "__neg__", operand->type);
src/AST/verify_types.cpp:429:        type = static_cast<Function *>(t)->output;
src/AST/verify_types.cpp:431:        error_log.log(loc, type->to_string() + " has no negation operator.");
src/AST/verify_types.cpp:436:      error_log.log(loc, type->to_string() + " has no negation operator.");
src/AST/verify_types.cpp:441:    if (operand->type == Uint || operand->type == Int ||
src/AST/verify_types.cpp:442:        operand->type == Char) {
src/AST/verify_types.cpp:443:      type = Range(operand->type);
src/AST/verify_types.cpp:445:      error_log.log(loc, type->to_string() + " cannot be part of a range");
src/AST/verify_types.cpp:450:    if (operand->type == Bool) {
src/AST/verify_types.cpp:472:  operand->verify_types();
src/AST/verify_types.cpp:473:  auto base_type = operand->type;
src/AST/verify_types.cpp:482:  while (base_type->is_pointer()) {
src/AST/verify_types.cpp:483:    base_type = static_cast<Pointer *>(base_type)->pointee;
src/AST/verify_types.cpp:486:  if (base_type->is_array()) {
src/AST/verify_types.cpp:492:      if (array_base_type->fixed_length) {
src/AST/verify_types.cpp:493:        error_log.log(loc, "Cannot resize a fixed-length array.");
src/AST/verify_types.cpp:499:      // account, but we're just dealing with it at code-gen time?
src/AST/verify_types.cpp:500:      type = Func(/*Ptr(operand->type), */ Uint, Void);
src/AST/verify_types.cpp:507:      operand->evaluate(ctx);
src/AST/verify_types.cpp:513:    auto evaled_type = operand->evaluate(ctx).as_type;
src/AST/verify_types.cpp:514:    if (evaled_type->is_enum()) {
src/AST/verify_types.cpp:517:      if (enum_type->get_value(member_name)) {
src/AST/verify_types.cpp:519:        type = operand->evaluate(ctx).as_type;
src/AST/verify_types.cpp:522:        error_log.log(loc, evaled_type->to_string() + " has no member " +
src/AST/verify_types.cpp:530:  if (base_type->is_struct()) {
src/AST/verify_types.cpp:532:    struct_type->ast_expression->CompleteDefinition();
src/AST/verify_types.cpp:534:    auto member_type = struct_type->field(member_name);
src/AST/verify_types.cpp:540:        error_log.log(loc, "Objects of type " + base_type->to_string() +
src/AST/verify_types.cpp:547:  if (base_type->is_primitive() || base_type->is_array() ||
src/AST/verify_types.cpp:548:      base_type->is_function()) {
src/AST/verify_types.cpp:550:      error_log.log(loc, base_type->to_string() + " has no field named '" +
src/AST/verify_types.cpp:569:  if (expr->type->is_quantum()) {
src/AST/verify_types.cpp:572:    for (auto opt : static_cast<QuantumType *>(expr->type)->options) {
src/AST/verify_types.cpp:573:      assert(opt->is_function());
src/AST/verify_types.cpp:578:  } else if (expr->type->is_function() || expr->type == Type_) {
src/AST/verify_types.cpp:580:    assert(expr->type != Type_ || expr->value.as_type->is_parametric_struct());
src/AST/verify_types.cpp:582:    potential_match_options.emplace_back(expr->type, expr);
src/AST/verify_types.cpp:591:  if (op == Language::Operator::Call && lhs->is_access()) {
src/AST/verify_types.cpp:594:    lhs_access->Verify(false);
src/AST/verify_types.cpp:598:    if (lhs_access->type == Error && lhs_access->operand->type != Error) {
src/AST/verify_types.cpp:600:          scope_->IdentifierBeingReferencedOrNull(lhs_access->member_name);
src/AST/verify_types.cpp:608:      if (lhs_access->operand->type->is_pointer()) {
src/AST/verify_types.cpp:609:        ufcs_ptr = lhs_access->operand;
src/AST/verify_types.cpp:612:        unop->op      = Language::Operator::And;
src/AST/verify_types.cpp:613:        unop->operand = lhs_access->operand;
src/AST/verify_types.cpp:614:        unop->type    = Ptr(unop->operand->type);
src/AST/verify_types.cpp:623:        if (rhs->is_comma_list()) {
src/AST/verify_types.cpp:625:          rhs_chainop->ops.push_back(Language::Operator::Comma);
src/AST/verify_types.cpp:626:          rhs_chainop->exprs.insert(rhs_chainop->exprs.begin(), ufcs_ptr);
src/AST/verify_types.cpp:631:          new_rhs->ops.push_back(Language::Operator::Comma);
src/AST/verify_types.cpp:632:          new_rhs->exprs.push_back(ufcs_ptr);
src/AST/verify_types.cpp:633:          new_rhs->exprs.push_back(rhs); // Pointer to rhs?
src/AST/verify_types.cpp:642:  lhs->verify_types();
src/AST/verify_types.cpp:645:    rhs->verify_types();
src/AST/verify_types.cpp:651:    if (!lhs->type->is_function()) {
src/AST/verify_types.cpp:657:    auto fn = static_cast<Function *>(lhs->type);
src/AST/verify_types.cpp:658:    if (fn->input != Void) {
src/AST/verify_types.cpp:662:      type = fn->output;
src/AST/verify_types.cpp:669:  if (lhs->type == Error || rhs->type == Error) {
src/AST/verify_types.cpp:677:    if (rhs->is_terminal()) {
src/AST/verify_types.cpp:679:      if (term->terminal_type == Language::Terminal::Null) {
src/AST/verify_types.cpp:680:        term->type = lhs->type;
src/AST/verify_types.cpp:685:      if (term->terminal_type == Language::Terminal::Hole) {
src/AST/verify_types.cpp:687:        term->type = lhs->type;
src/AST/verify_types.cpp:689:        // if (lhs->is_declaration()) { ((Declaration *)lhs)->init = false; }
src/AST/verify_types.cpp:695:    if (lhs->type != rhs->type) {
src/AST/verify_types.cpp:696:      if (lhs->type->is_array() && rhs->type->is_array()) {
src/AST/verify_types.cpp:697:        auto lhs_array_type = (Array *)lhs->type;
src/AST/verify_types.cpp:698:        auto rhs_array_type = (Array *)rhs->type;
src/AST/verify_types.cpp:699:        if (lhs_array_type->data_type != rhs_array_type->data_type) {
src/AST/verify_types.cpp:703:        } else if (lhs_array_type->fixed_length &&
src/AST/verify_types.cpp:704:                   rhs_array_type->fixed_length) {
src/AST/verify_types.cpp:708:        } else if (lhs_array_type->fixed_length) {
src/AST/verify_types.cpp:709:          error_log.log(loc, "Invalid assignment. Array on right-hand side has "
src/AST/verify_types.cpp:712:                                 std::to_string(lhs_array_type->len));
src/AST/verify_types.cpp:714:          assert(rhs_array_type->fixed_length);
src/AST/verify_types.cpp:719:        error_log.log(loc, "Invalid assignment. Left-hand side has type " +
src/AST/verify_types.cpp:720:                               lhs->type->to_string() +
src/AST/verify_types.cpp:721:                               ", but right-hand side has type " +
src/AST/verify_types.cpp:722:                               rhs->type->to_string());
src/AST/verify_types.cpp:731:    if (lhs->type != Bool) {
src/AST/verify_types.cpp:741:    if (lhs->is_identifier()) {
src/AST/verify_types.cpp:742:      auto id_token = static_cast<AST::Identifier *>(lhs)->token;
src/AST/verify_types.cpp:744:      for (auto scope_ptr = scope_; scope_ptr; scope_ptr = scope_ptr->parent) {
src/AST/verify_types.cpp:745:        auto id_ptr = scope_ptr->IdentifierHereOrNull(id_token);
src/AST/verify_types.cpp:763:      if (opt.match->is_function()) {
src/AST/verify_types.cpp:765:        if (MatchCall(static_cast<Function *>(opt.match)->input, rhs->type,
src/AST/verify_types.cpp:771:          has_vars_flag = matched_data.expr->type->has_vars;
src/AST/verify_types.cpp:772:          if (matched_data.expr->is_identifier()) {
src/AST/verify_types.cpp:775:                !static_cast<Identifier *>(matched_data.expr)->arg_val;
src/AST/verify_types.cpp:779:        assert(opt.expr->value.as_type->is_parametric_struct());
src/AST/verify_types.cpp:796:              << "Line " << pmo.expr->loc.line_num << ": " << pmo.err;
src/AST/verify_types.cpp:798:                 static_cast<Function *>(pmo.match)->input->to_string() +
src/AST/verify_types.cpp:799:                 " vs. " + rhs->type->to_string() + " on line " +
src/AST/verify_types.cpp:800:                 std::to_string(pmo.expr->loc.line_num);
src/AST/verify_types.cpp:812:    if (evaled_type->is_function()) {
src/AST/verify_types.cpp:813:      type = static_cast<Function *>(evaled_type)->output;
src/AST/verify_types.cpp:819:        for (auto &gen : fn_expr->cache) {
src/AST/verify_types.cpp:820:          if (gen.first == static_cast<Function *>(evaled_type)->input) {
src/AST/verify_types.cpp:826:        fn_expr->cache[rhs->type] =
src/AST/verify_types.cpp:836:    if (!lhs->type->is_array()) {
src/AST/verify_types.cpp:843:    if (rhs->type->is_range()) {
src/AST/verify_types.cpp:844:      type = Slice(static_cast<Array *>(lhs->type));
src/AST/verify_types.cpp:848:    type = static_cast<Array *>(lhs->type)->data_type;
src/AST/verify_types.cpp:851:    if (rhs->type == Int) { break; }
src/AST/verify_types.cpp:852:    if (rhs->type == Uint) { break; }
src/AST/verify_types.cpp:856:                      rhs->type->to_string());
src/AST/verify_types.cpp:863:    type = rhs->evaluate(ctx).as_type;
src/AST/verify_types.cpp:867:    if (lhs->type == type ||
src/AST/verify_types.cpp:868:        (lhs->type == Bool && (type == Int || type == Uint || type == Real)) ||
src/AST/verify_types.cpp:869:        (lhs->type == Int && type == Real) ||
src/AST/verify_types.cpp:870:        (lhs->type == Int && type == Uint) ||
src/AST/verify_types.cpp:871:        (lhs->type == Uint && type == Real) ||
src/AST/verify_types.cpp:872:        (lhs->type == Uint && type == Int)) {
src/AST/verify_types.cpp:876:    if (lhs->type->is_pointer() && type->is_pointer()) { return; }
src/AST/verify_types.cpp:878:    error_log.log(loc, "Invalid cast from " + lhs->type->to_string() + " to " +
src/AST/verify_types.cpp:879:                           type->to_string());
src/AST/verify_types.cpp:882:    if (lhs->type == Int && rhs->type == Int) {
src/AST/verify_types.cpp:885:    } else if (lhs->type == Uint && rhs->type == Uint) {
src/AST/verify_types.cpp:888:    } else if (lhs->type == Char && rhs->type == Char) {
src/AST/verify_types.cpp:893:                             lhs->type->to_string() + " .. " +
src/AST/verify_types.cpp:894:                             rhs->type->to_string());
src/AST/verify_types.cpp:898:    if (lhs->type == Bool && rhs->type == Bool) {
src/AST/verify_types.cpp:906:    if (lhs->type == Bool && rhs->type == Bool) {
src/AST/verify_types.cpp:914:    if (lhs->type == Bool && rhs->type == Bool) {
src/AST/verify_types.cpp:924:    if ((lhs->type == Int && rhs->type == Int) ||                              \
src/AST/verify_types.cpp:925:        (lhs->type == Uint && rhs->type == Uint) ||                            \
src/AST/verify_types.cpp:926:        (lhs->type == Real && rhs->type == Real)) {                            \
src/AST/verify_types.cpp:930:           scope_ptr = scope_ptr->parent) {                                    \
src/AST/verify_types.cpp:931:        auto id_ptr = scope_ptr->IdentifierHereOrNull("__" op_name "__");      \
src/AST/verify_types.cpp:933:        id_ptr->verify_types();                                                \
src/AST/verify_types.cpp:936:                                                 Tup({lhs->type, rhs->type})); \
src/AST/verify_types.cpp:938:        type = static_cast<Function *>(fn_type)->output;                       \
src/AST/verify_types.cpp:943:                               lhs->type->to_string() + " and " +              \
src/AST/verify_types.cpp:944:                               rhs->type->to_string());                        \
src/AST/verify_types.cpp:949:    CASE(Add, "add", "+", lhs->type);
src/AST/verify_types.cpp:950:    CASE(Sub, "sub", "-", lhs->type);
src/AST/verify_types.cpp:951:    CASE(Div, "div", "/", lhs->type);
src/AST/verify_types.cpp:952:    CASE(Mod, "mod", "%", lhs->type);
src/AST/verify_types.cpp:954:    CASE(SubEq, "sub_eq", "-=", Void);
src/AST/verify_types.cpp:963:    if ((lhs->type == Int && rhs->type == Int) ||
src/AST/verify_types.cpp:964:        (lhs->type == Uint && rhs->type == Uint) ||
src/AST/verify_types.cpp:965:        (lhs->type == Real && rhs->type == Real)) {
src/AST/verify_types.cpp:966:      type = lhs->type;
src/AST/verify_types.cpp:968:    } else if (lhs->type->is_function() && rhs->type->is_function()) {
src/AST/verify_types.cpp:969:      auto lhs_fn = (Function *)lhs->type;
src/AST/verify_types.cpp:970:      auto rhs_fn = (Function *)rhs->type;
src/AST/verify_types.cpp:971:      if (rhs_fn->output == lhs_fn->input) {
src/AST/verify_types.cpp:972:        type = Func(rhs_fn->input, lhs_fn->output);
src/AST/verify_types.cpp:980:      for (auto scope_ptr = scope_; scope_ptr; scope_ptr = scope_ptr->parent) {
src/AST/verify_types.cpp:981:        auto id_ptr = scope_ptr->IdentifierHereOrNull("__mul__");
src/AST/verify_types.cpp:988:                                                 Tup({lhs->type, rhs->type}));
src/AST/verify_types.cpp:990:        type = static_cast<Function *>(fn_type)->output;
src/AST/verify_types.cpp:994:                               lhs->type->to_string() + " and " +
src/AST/verify_types.cpp:995:                               rhs->type->to_string());
src/AST/verify_types.cpp:1000:    if (lhs->type != Type_) {
src/AST/verify_types.cpp:1002:      error_log.log(loc, "From-type for a function must be a type.");
src/AST/verify_types.cpp:1004:    if (rhs->type != Type_) {
src/AST/verify_types.cpp:1006:      error_log.log(loc, "To-type for a function must be a type.");
src/AST/verify_types.cpp:1018:  for (auto e : exprs) { e->verify_types(); }
src/AST/verify_types.cpp:1030:      type_vec[position] = eptr->type;
src/AST/verify_types.cpp:1031:      all_types &= (eptr->type == Type_);
src/AST/verify_types.cpp:1043:  for (const auto &expr : exprs) { expr_types.insert(expr->type); }
src/AST/verify_types.cpp:1063:  test_fn->verify_types();
src/AST/verify_types.cpp:1067:  if (!test_fn->type->is_function()) {
src/AST/verify_types.cpp:1072:    identifier->type = Error;
src/AST/verify_types.cpp:1076:  auto test_func_type = (Function *)(test_fn->type);
src/AST/verify_types.cpp:1077:  if (test_func_type->output != Bool) {
src/AST/verify_types.cpp:1078:    // TODO What about implicitly cast-able to bool via a user-defined cast?
src/AST/verify_types.cpp:1084:  if (test_func_type->input != Type_) {
src/AST/verify_types.cpp:1092:  identifier->type = type;
src/AST/verify_types.cpp:1097:  container->verify_types();
src/AST/verify_types.cpp:1099:  if (container->type == Void) {
src/AST/verify_types.cpp:1105:  if (container->type->is_array()) {
src/AST/verify_types.cpp:1106:    type = static_cast<Array *>(container->type)->data_type;
src/AST/verify_types.cpp:1108:  } else if (container->type->is_slice()) {
src/AST/verify_types.cpp:1109:    type = static_cast<SliceType *>(container->type)->array_type->data_type;
src/AST/verify_types.cpp:1111:  } else if (container->type->is_range()) {
src/AST/verify_types.cpp:1112:    type = static_cast<RangeType *>(container->type)->end_type;
src/AST/verify_types.cpp:1114:  } else if (container->type == Type_) {
src/AST/verify_types.cpp:1116:    auto t = container->evaluate(ctx).as_type;
src/AST/verify_types.cpp:1117:    if (t->is_enum()) { type = t; }
src/AST/verify_types.cpp:1124:  identifier->type = type;
src/AST/verify_types.cpp:1140:    } else if (t->is_parametric_struct()) {
src/AST/verify_types.cpp:1160:  } else if (type->is_parametric_struct()) {
src/AST/verify_types.cpp:1170:  if (!type->is_function()) {
src/AST/verify_types.cpp:1176:  if (!fn_type->input->is_struct()) {
src/AST/verify_types.cpp:1178:                           fn_type->input->to_string());
src/AST/verify_types.cpp:1181:  if (fn_type->output != Void) {
src/AST/verify_types.cpp:1187:  if (!type->is_function()) {
src/AST/verify_types.cpp:1193:  if (!fn_type->input->is_tuple()) {
src/AST/verify_types.cpp:1195:                           fn_type->input->to_string());
src/AST/verify_types.cpp:1197:    auto in = (Tuple *)(fn_type->input);
src/AST/verify_types.cpp:1198:    if (in->entries.size() != 2) {
src/AST/verify_types.cpp:1200:                             std::to_string(in->entries.size()) + "argument" +
src/AST/verify_types.cpp:1201:                             (in->entries.size() != 1 ? "s" : "") + " given.");
src/AST/verify_types.cpp:1206:  if (fn_type->output != Void) {
src/AST/verify_types.cpp:1212:  if (!type->is_function()) {
src/AST/verify_types.cpp:1218:  if (!fn_type->input->is_pointer()) {
src/AST/verify_types.cpp:1221:  } else if (!((Pointer *)(fn_type->input))->pointee->is_struct()) {
src/AST/verify_types.cpp:1225:  if (fn_type->output != Void) {
src/AST/verify_types.cpp:1234:  if (type_expr) { type_expr->verify_types(); }
src/AST/verify_types.cpp:1235:  if (init_val) { init_val->verify_types(); }
src/AST/verify_types.cpp:1238:  scope_->ordered_decls_.push_back(this);
src/AST/verify_types.cpp:1244:  //   4. I: T = --
src/AST/verify_types.cpp:1251:    type = type_expr->VerifyTypeForDeclaration(identifier->token);
src/AST/verify_types.cpp:1252:    identifier->type = type;
src/AST/verify_types.cpp:1255:    type = init_val->VerifyValueForDeclaration(identifier->token);
src/AST/verify_types.cpp:1256:    identifier->type = type;
src/AST/verify_types.cpp:1259:    type   = type_expr->VerifyTypeForDeclaration(identifier->token);
src/AST/verify_types.cpp:1260:    auto t = init_val->VerifyValueForDeclaration(identifier->token);
src/AST/verify_types.cpp:1268:    type   = type_expr->VerifyTypeForDeclaration(identifier->token);
src/AST/verify_types.cpp:1269:    identifier->type = type;
src/AST/verify_types.cpp:1270:    init_val->type = type;
src/AST/verify_types.cpp:1277:    identifier->type = Error;
src/AST/verify_types.cpp:1281:  if (type->is_struct()) {
src/AST/verify_types.cpp:1282:    ((Structure *)type)->ast_expression->CompleteDefinition();
src/AST/verify_types.cpp:1289:    if (init_val->is_struct_literal()) {
src/AST/verify_types.cpp:1290:      assert(init_val->value.as_type && init_val->value.as_type->is_struct());
src/AST/verify_types.cpp:1297:      ((Structure *)(init_val->value.as_type))->set_name(identifier->token);
src/AST/verify_types.cpp:1299:    } else if (init_val->is_parametric_struct_literal()) {
src/AST/verify_types.cpp:1303:      assert(init_val->value.as_type &&
src/AST/verify_types.cpp:1304:             init_val->value.as_type->is_parametric_struct());
src/AST/verify_types.cpp:1308:      ((ParametricStructure *)(init_val->value.as_type))
src/AST/verify_types.cpp:1309:          ->set_name(identifier->token);
src/AST/verify_types.cpp:1311:    } else if (init_val->is_enum_literal()) {
src/AST/verify_types.cpp:1314:      init_val->evaluate(ctx); // TODO do we need to evaluate here?
src/AST/verify_types.cpp:1315:      assert(init_val->value.as_type);
src/AST/verify_types.cpp:1319:      ((Enumeration *)(init_val->value.as_type))->bound_name =
src/AST/verify_types.cpp:1320:          identifier->token;
src/AST/verify_types.cpp:1326:    identifier->value = init_val->value;
src/AST/verify_types.cpp:1342:  if (identifier->token == "__print__") {
src/AST/verify_types.cpp:1345:  } else if (identifier->token == "__assign__") {
src/AST/verify_types.cpp:1348:  } else if (identifier->token == "__destroy__") {
src/AST/verify_types.cpp:1355:  length->verify_types();
src/AST/verify_types.cpp:1356:  data_type->verify_types();
src/AST/verify_types.cpp:1358:  assert(length && data_type->type == Type_);
src/AST/verify_types.cpp:1362:  if (length->is_terminal() &&
src/AST/verify_types.cpp:1363:      static_cast<Terminal *>(length)->terminal_type ==
src/AST/verify_types.cpp:1369:  if (length->type != Int && length->type != Uint) {
src/AST/verify_types.cpp:1370:    error_log.log(loc, "Array length indexed by non-integral type");
src/AST/verify_types.cpp:1376:  for (auto e : elems) { e->verify_types(); }
src/AST/verify_types.cpp:1384:  auto type_to_match = elems.front()->type;
src/AST/verify_types.cpp:1393:    if (el->type != type_to_match) {
src/AST/verify_types.cpp:1404:    in->verify_types();
src/AST/verify_types.cpp:1405:    input_has_vars |= in->type->has_vars;
src/AST/verify_types.cpp:1410:  return_type_expr->verify_types();
src/AST/verify_types.cpp:1413:  Type *ret_type = return_type_expr->evaluate(ctx).as_type;
src/AST/verify_types.cpp:1421:    input_type = inputs.front()->type;
src/AST/verify_types.cpp:1425:    for (const auto &input : inputs) { input_type_vec.push_back(input->type); }
src/AST/verify_types.cpp:1438:    kv.first->verify_types();
src/AST/verify_types.cpp:1439:    kv.second->verify_types();
src/AST/verify_types.cpp:1445:    if (kv.first->type == Error) {
src/AST/verify_types.cpp:1446:      kv.first->type = Bool;
src/AST/verify_types.cpp:1447:      if (kv.second->type == Error) { continue; }
src/AST/verify_types.cpp:1449:    } else if (kv.first->type != Bool) {
src/AST/verify_types.cpp:1454:                             kv.first->type->to_string() + " found instead.");
src/AST/verify_types.cpp:1455:      kv.first->type = Bool;
src/AST/verify_types.cpp:1456:      assert(kv.first->type && "keytype");
src/AST/verify_types.cpp:1459:    value_types.insert(kv.second->type);
src/AST/verify_types.cpp:1466:      error_log.log(loc, "Type error: Values do not match in key-value pairs");
src/AST/verify_types.cpp:1475:  for (auto stmt : statements) { stmt->verify_types(); }
src/AST/verify_types.cpp:1481:  condition->verify_types();
src/AST/verify_types.cpp:1482:  statements->verify_types();
src/AST/verify_types.cpp:1484:  if (condition->type == Error) { return; }
src/AST/verify_types.cpp:1486:  if (condition->type != Bool) {
src/AST/verify_types.cpp:1489:                           condition->type->to_string() + " given.");
src/AST/verify_types.cpp:1494:  for (auto iter : iterators) { iter->verify_types(); }
src/AST/verify_types.cpp:1495:  statements->verify_types();
src/AST/verify_types.cpp:1499:  for (auto cond : conditions) { cond->verify_types(); }
src/AST/verify_types.cpp:1500:  for (auto stmts : statements) { stmts->verify_types(); }
src/AST/verify_types.cpp:1503:    if (cond->type == Error) { continue; }
src/AST/verify_types.cpp:1504:    if (cond->type != Bool) {
src/AST/verify_types.cpp:1506:                             cond->type->to_string() + " given.");
src/AST/verify_types.cpp:1527:    assert(scope_ptr->is_block_scope());
src/AST/verify_types.cpp:1529:    if (block_scope_ptr->type == ScopeType::Function) {
src/AST/verify_types.cpp:1536:    if (block_scope_ptr->is_loop_scope()) {
src/AST/verify_types.cpp:1541:    scope_ptr = block_scope_ptr->parent;
src/IR/EmitIR.cpp:12:  return t->is_big() ? v : IR::Load(t, v);
src/IR/EmitIR.cpp:17:  size_t alignment = decl->type->alignment();
src/IR/EmitIR.cpp:18:  size_t bytes     = decl->type->bytes();
src/IR/EmitIR.cpp:20:  // Compile-time variables actually take up space in the IR!
src/IR/EmitIR.cpp:26:  frame_map[decl->identifier] = frame_size;
src/IR/EmitIR.cpp:46:    IR::Block::Current->exit.SetReturnVoid();
src/IR/EmitIR.cpp:57:  if (expr->type->is_primitive()) {
src/IR/EmitIR.cpp:58:    IR::Print(expr->EmitIR());
src/IR/EmitIR.cpp:68:    auto result = operand->EmitIR();
src/IR/EmitIR.cpp:69:    IR::Block::Current->exit.SetReturn(result);
src/IR/EmitIR.cpp:78:    if (operand->is_comma_list()) {
src/IR/EmitIR.cpp:80:      for (auto op : operand_as_chainop->exprs) { EmitPrintExpr(op); }
src/IR/EmitIR.cpp:87:    auto val = operand->EmitIR();
src/IR/EmitIR.cpp:88:    if (operand->type == Type_) {
src/IR/EmitIR.cpp:95:    auto val = operand->EmitIR();
src/IR/EmitIR.cpp:96:    if (operand->type == Int) {
src/IR/EmitIR.cpp:99:    } else if (operand->type == Real) {
src/IR/EmitIR.cpp:107:    auto val = operand->EmitIR();
src/IR/EmitIR.cpp:108:    if (operand->type == Bool) {
src/IR/EmitIR.cpp:116:    return IR::Load(operand->type, operand->EmitIR());
src/IR/EmitIR.cpp:125:    return IR::Store(rhs->type, rhs->EmitIR(), lhs->EmitLVal());
src/IR/EmitIR.cpp:129:    return IR::TC_Arrow(lhs->EmitIR(), rhs->EmitIR());
src/IR/EmitIR.cpp:133:    if (lhs->type == Bool && rhs->type == Bool) {
src/IR/EmitIR.cpp:134:      auto lval    = lhs->EmitLVal();
src/IR/EmitIR.cpp:135:      auto lhs_val = IR::Load(lhs->type, lval);
src/IR/EmitIR.cpp:137:      auto load_rhs_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:138:      auto land_block     = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:140:      IR::Block::Current->exit.SetConditional(
src/IR/EmitIR.cpp:146:      auto rhs_val       = rhs->EmitIR();
src/IR/EmitIR.cpp:149:      IR::Block::Current->exit.SetUnconditional(land_block);
src/IR/EmitIR.cpp:158:    auto lval    = lhs->EmitLVal();
src/IR/EmitIR.cpp:159:    auto lhs_val = IR::Load(lhs->type, lval);
src/IR/EmitIR.cpp:160:    auto rhs_val = rhs->EmitIR();
src/IR/EmitIR.cpp:162:    if (lhs->type == Bool && rhs->type == Bool) {
src/IR/EmitIR.cpp:170:    auto lval    = lhs->EmitLVal();                                            \
src/IR/EmitIR.cpp:171:    auto lhs_val = IR::Load(lhs->type, lval);                                  \
src/IR/EmitIR.cpp:172:    auto rhs_val = rhs->EmitIR();                                              \
src/IR/EmitIR.cpp:174:    if (lhs->type == Int && rhs->type == Int) {                                \
src/IR/EmitIR.cpp:177:    } else if (lhs->type == Uint && rhs->type == Uint) {                       \
src/IR/EmitIR.cpp:180:    } else if (lhs->type == Real && rhs->type == Real) {                       \
src/IR/EmitIR.cpp:198:    auto lhs_val = lhs->EmitIR();                                              \
src/IR/EmitIR.cpp:199:    auto rhs_val = rhs->EmitIR();                                              \
src/IR/EmitIR.cpp:200:    if (lhs->type == Int && rhs->type == Int) {                                \
src/IR/EmitIR.cpp:203:    } else if (lhs->type == Uint && rhs->type == Uint) {                       \
src/IR/EmitIR.cpp:206:    } else if (lhs->type == Real && rhs->type == Real) {                       \
src/IR/EmitIR.cpp:226:    auto result = IR::CallCmd(lhs->EmitIR());
src/IR/EmitIR.cpp:228:      if (rhs->is_comma_list()) {
src/IR/EmitIR.cpp:229:        for (auto expr : ((ChainOp *)rhs)->exprs) {
src/IR/EmitIR.cpp:230:          result.args.push_back(expr->EmitIR());
src/IR/EmitIR.cpp:233:        result.args.push_back(rhs->EmitIR());
src/IR/EmitIR.cpp:237:    IR::Block::Current->cmds.push_back(result);
src/IR/EmitIR.cpp:277:    } else if (op_type->is_function()) {
src/IR/EmitIR.cpp:294:    } else if (op_type->is_function()) {
src/IR/EmitIR.cpp:324:    for (auto e : exprs) { vals.push_back(e->EmitIR()); }
src/IR/EmitIR.cpp:338:    for (auto &b : blocks) { b = IR::Func::Current->AddBlock(); }
src/IR/EmitIR.cpp:340:    IR::Block::Current->exit.SetUnconditional(blocks.front());
src/IR/EmitIR.cpp:343:    IR::Block *landing_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:346:    for (size_t i = 0; i < exprs.size() - 1; ++i) {
src/IR/EmitIR.cpp:348:      auto result = exprs[i]->EmitIR();
src/IR/EmitIR.cpp:350:        IR::Block::Current->exit.SetConditional(result, landing_block,
src/IR/EmitIR.cpp:353:        IR::Block::Current->exit.SetConditional(result, blocks[i + 1],
src/IR/EmitIR.cpp:360:    auto last_result = exprs.back()->EmitIR();
src/IR/EmitIR.cpp:361:    IR::Block::Current->exit.SetUnconditional(landing_block);
src/IR/EmitIR.cpp:365:    landing_block->cmds.push_back(phi);
src/IR/EmitIR.cpp:371:    std::vector<IR::Block *> blocks(exprs.size() - 1, nullptr);
src/IR/EmitIR.cpp:373:    for (auto &b : blocks) { b = IR::Func::Current->AddBlock(); }
src/IR/EmitIR.cpp:375:    IR::Block *landing_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:379:    IR::Value rhs = exprs[0]->EmitIR();
src/IR/EmitIR.cpp:380:    IR::Block::Current->exit.SetUnconditional(blocks.front());
src/IR/EmitIR.cpp:382:    for (size_t i = 0; i < exprs.size() - 2; ++i) {
src/IR/EmitIR.cpp:385:      rhs                = exprs[i + 1]->EmitIR();
src/IR/EmitIR.cpp:386:      result             = EmitComparison(exprs[i]->type, ops[i], lhs, rhs);
src/IR/EmitIR.cpp:389:      IR::Block::Current->exit.SetConditional(result, blocks[i + 1],
src/IR/EmitIR.cpp:397:    rhs              = exprs.back()->EmitIR();
src/IR/EmitIR.cpp:398:    auto last_result = EmitComparison(exprs.back()->type, ops.back(), lhs, rhs);
src/IR/EmitIR.cpp:399:    IR::Block::Current->exit.SetUnconditional(landing_block);
src/IR/EmitIR.cpp:403:    landing_block->cmds.push_back(phi);
src/IR/EmitIR.cpp:414:  IR::Block::Current = ir_func->entry();
src/IR/EmitIR.cpp:416:  statements->verify_types();
src/IR/EmitIR.cpp:421:  for (auto decl : fn_scope->ordered_decls_) {
src/IR/EmitIR.cpp:422:    if (decl->identifier->arg_val) { continue; }
src/IR/EmitIR.cpp:423:    ir_func->PushLocal(decl);
src/IR/EmitIR.cpp:426:  for (auto scope : fn_scope->innards_) {
src/IR/EmitIR.cpp:427:    for (auto decl : scope->ordered_decls_) {
src/IR/EmitIR.cpp:428:      if (decl->identifier->arg_val) { continue; }
src/IR/EmitIR.cpp:429:      ir_func->PushLocal(decl);
src/IR/EmitIR.cpp:433:  statements->EmitIR();
src/IR/EmitIR.cpp:435:  if (debug::ct_eval) { ir_func->dump(); }
src/IR/EmitIR.cpp:441:  for (auto stmt : statements) { stmt->EmitIR(); }
src/IR/EmitIR.cpp:446:  if (arg_val && arg_val->is_function_literal()) {
src/IR/EmitIR.cpp:450:    for (auto in : fn->inputs) {
src/IR/EmitIR.cpp:451:      if (this != in->identifier) {
src/IR/EmitIR.cpp:461:  } else if (type->is_function()) {
src/IR/EmitIR.cpp:467:    auto func_to_call  = value.as_expr->EmitIR();
src/IR/EmitIR.cpp:474:        type, IR::Value::Alloc(IR::Func::Current->frame_map.at(this)));
src/IR/EmitIR.cpp:481:  if (length->is_hole()) {
src/IR/EmitIR.cpp:482:    return IR::TC_Arr1(data_type->EmitIR());
src/IR/EmitIR.cpp:484:    return IR::TC_Arr2(length->EmitIR(), data_type->EmitIR());
src/IR/EmitIR.cpp:492:    if (lhs_type->is_primitive() || lhs_type->is_pointer() ||
src/IR/EmitIR.cpp:493:        lhs_type->is_enum()) {
src/IR/EmitIR.cpp:506:    type->EmitInit(identifier->EmitLVal());
src/IR/EmitIR.cpp:509:    auto id_val  = identifier->EmitLVal();
src/IR/EmitIR.cpp:510:    auto rhs_val = init_val->EmitIR();
src/IR/EmitIR.cpp:512:    EmitAssignment(scope_, identifier->type, init_val->type, id_val, rhs_val);
src/IR/EmitIR.cpp:522:  for (auto &b : key_blocks) { b = IR::Func::Current->AddBlock(); }
src/IR/EmitIR.cpp:525:  IR::Block *landing_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:528:  IR::Block::Current->exit.SetUnconditional(key_blocks.front());
src/IR/EmitIR.cpp:531:  for (size_t i = 0; i < key_vals.size() - 1; ++i) {
src/IR/EmitIR.cpp:532:    auto compute_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:535:    result = key_vals[i].first->EmitIR();
src/IR/EmitIR.cpp:536:    IR::Block::Current->exit.SetConditional(result, compute_block,
src/IR/EmitIR.cpp:540:    result = key_vals[i].second->EmitIR();
src/IR/EmitIR.cpp:541:    IR::Block::Current->exit.SetUnconditional(landing_block);
src/IR/EmitIR.cpp:547:  result = key_vals.back().second->EmitIR();
src/IR/EmitIR.cpp:548:  IR::Block::Current->exit.SetUnconditional(landing_block);
src/IR/EmitIR.cpp:552:  landing_block->cmds.push_back(phi);
src/IR/EmitIR.cpp:559:  if (operand->type == Type_) {
src/IR/EmitIR.cpp:561:      return IR::Bytes(operand->EmitIR());
src/IR/EmitIR.cpp:564:      return IR::Alignment(operand->EmitIR());
src/IR/EmitIR.cpp:569:  auto eval      = operand->EmitIR();
src/IR/EmitIR.cpp:570:  auto base_type = operand->type;
src/IR/EmitIR.cpp:571:  while (base_type->is_pointer()) {
src/IR/EmitIR.cpp:572:    base_type = ((Pointer *)base_type)->pointee;
src/IR/EmitIR.cpp:573:    if (!base_type->is_big()) { eval = IR::Load(base_type, eval); }
src/IR/EmitIR.cpp:577:  if (base_type->is_array() && member_name == "size") {
src/IR/EmitIR.cpp:579:    if (array_type->fixed_length) {
src/IR/EmitIR.cpp:580:      return IR::Value(array_type->len);
src/IR/EmitIR.cpp:583:      IR::Block::Current->push(gep);
src/IR/EmitIR.cpp:584:      return IR::Load(array_type->data_type, gep);
src/IR/EmitIR.cpp:588:  if (base_type->is_struct()) {
src/IR/EmitIR.cpp:591:    if (!type->stores_data()) { NOT_YET; }
src/IR/EmitIR.cpp:595:                {0, (int)(struct_type->field_name_to_num AT(member_name))});
src/IR/EmitIR.cpp:596:    IR::Block::Current->push(elem_ptr);
src/IR/EmitIR.cpp:605:  auto cond_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:606:  auto body_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:607:  auto land_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:609:  IR::Block::Current->exit.SetUnconditional(cond_block);
src/IR/EmitIR.cpp:612:  auto cond_val = condition->EmitIR();
src/IR/EmitIR.cpp:613:  IR::Block::Current->exit.SetConditional(cond_val, body_block, land_block);
src/IR/EmitIR.cpp:616:  // for (auto decl : while_scope->ordered_decls_) { /* TODO Initialize */ }
src/IR/EmitIR.cpp:617:  statements->EmitIR();
src/IR/EmitIR.cpp:621:  IR::Block::Current->exit.SetUnconditional(cond_block);
src/IR/EmitIR.cpp:631:  for (auto &b : cond_blocks) { b = IR::Func::Current->AddBlock(); }
src/IR/EmitIR.cpp:632:  for (auto &b : body_blocks) { b = IR::Func::Current->AddBlock(); }
src/IR/EmitIR.cpp:633:  auto land_block = IR::Func::Current->AddBlock();
src/IR/EmitIR.cpp:635:  IR::Block::Current->exit.SetUnconditional(cond_blocks[0]);
src/IR/EmitIR.cpp:637:  for (size_t i = 0; i < conditions.size() - 1; ++i) {
src/IR/EmitIR.cpp:639:    auto cond_val = conditions[i]->EmitIR();
src/IR/EmitIR.cpp:640:    IR::Block::Current->exit.SetConditional(cond_val, body_blocks[i],
src/IR/EmitIR.cpp:645:  auto cond_val      = conditions.back()->EmitIR();
src/IR/EmitIR.cpp:646:  IR::Block::Current->exit.SetConditional(
src/IR/EmitIR.cpp:647:      cond_val, body_blocks[conditions.size() - 1],
src/IR/EmitIR.cpp:652:    statements[i]->EmitIR();
src/IR/EmitIR.cpp:654:    IR::Block::Current->exit.SetUnconditional(land_block);
src/IR/EmitLVal.cpp:5:  return IR::Value::RelAlloc(IR::Func::Current->frame_map.at(this));
src/IR/IR.h:196:    Block::Current->push(cmd);                                                 \
src/IR/IR.h:204:    Block::Current->push(cmd);                                                 \
src/IR/IR.h:212:  Block::Current->push(cmd);
src/IR/IR.h:219:  Block::Current->push(cmd);
src/IR/IR.h:235:  // Block::Current->cmds.push_back(phi);
src/IR/Ops.cpp:12:  result.val.as_ref = Func::Current->num_cmds;
src/IR/Ops.cpp:13:  Func::Current->num_cmds++;
src/IR/Ops.cpp:18:  result.val.as_ref = Func::Current->num_cmds;
src/IR/Ops.cpp:19:  Func::Current->num_cmds++;
src/IR/Ops.cpp:48:    if (value.val.as_func->name != "") {
src/IR/Ops.cpp:49:      os << value.val.as_func->name;
src/IR/Ops.cpp:70:      std::cout << "\n" << std::string(indent + 2, ' ') << "block-"
src/IR/Ops.cpp:71:                << incoming_blocks[i]->block_num << " => " << args[i];
src/IR/Ops.cpp:90:    std::cout << "  block-" << block_num << ":\n";
src/IR/Ops.cpp:102:    std::cout << "jmp block-" << true_block->block_num << "\n\n";
src/IR/Ops.cpp:106:    std::cout << "cond br " << val << " [T: block-" << true_block->block_num
src/IR/Ops.cpp:107:              << "] [F: block-" << false_block->block_num << "]\n\n";
src/IR/Ops.cpp:135:  for (auto b : blocks) { b->dump(); }
src/IR/Stack.h:39:  ~StackFrame() { stack->RemoveFrame(this); }
src/IR/eval.cpp:16:  int height = 1 + ((int)local_stack->used) / 4;
src/IR/eval.cpp:19:             local_stack->allocs[4 * i] & 0xff,
src/IR/eval.cpp:20:             local_stack->allocs[4 * i + 1] & 0xff,
src/IR/eval.cpp:21:             local_stack->allocs[4 * i + 2] & 0xff,
src/IR/eval.cpp:22:             local_stack->allocs[4 * i + 3] & 0xff);
src/IR/eval.cpp:24:  mvprintw(height, 0, "    [-------------]");
src/IR/eval.cpp:27:  mvprintw(0, 30, "block-%ld", frame.curr_block->block_num);
src/IR/eval.cpp:30:  for (const auto &cmd : frame.curr_block->cmds) {
src/IR/eval.cpp:49:  mvprintw(20, 50, "Stack size:     %ld", local_stack->used);
src/IR/eval.cpp:50:  mvprintw(21, 50, "Stack capacity: %ld", local_stack->capacity);
src/IR/eval.cpp:80:    frame.reg[result.val.as_ref] = Value(-cmd_inputs[0].val.as_int);
src/IR/eval.cpp:83:    frame.reg[result.val.as_ref] = Value(-cmd_inputs[0].val.as_real);
src/IR/eval.cpp:88:    assert(t->is_primitive() &&
src/IR/eval.cpp:89:           "Non-primitive local variables are not yet implemented");
src/IR/eval.cpp:94:        Value(*(stored_type *)(frame.stack->allocs + offset));                 \
src/IR/eval.cpp:111:    assert(t->is_primitive() &&
src/IR/eval.cpp:112:           "Non-primitive local variables are not yet implemented");
src/IR/eval.cpp:116:    store_type *ptr              = (store_type *)(frame.stack->allocs + offset); \
src/IR/eval.cpp:144:    if (cmd_inputs[0].val.as_type->is_array()) {
src/IR/eval.cpp:146:      if (array_type->fixed_length) {
src/IR/eval.cpp:153:                   array_type->data_type->bytes();
src/IR/eval.cpp:164:    } else if (cmd_inputs[0].val.as_type->is_struct()) {
src/IR/eval.cpp:172:      ptr += struct_type->field_offsets AT(field_index);
src/IR/eval.cpp:202:        Value(cmd_inputs[0].val.as_int - cmd_inputs[1].val.as_int);
src/IR/eval.cpp:206:        Value(cmd_inputs[0].val.as_uint - cmd_inputs[1].val.as_uint);
src/IR/eval.cpp:210:        Value(cmd_inputs[0].val.as_real - cmd_inputs[1].val.as_real);
src/IR/eval.cpp:373:      std::printf("%s", cmd_inputs[0].val.as_type->to_string().c_str());
src/IR/eval.cpp:398:    frame.reg[result.val.as_ref] = Value(cmd_inputs[0].val.as_type->bytes());
src/IR/eval.cpp:401:    frame.reg[result.val.as_ref] = Value(cmd_inputs[0].val.as_type->alignment());
src/IR/eval.cpp:425:    : reg(f->num_cmds), stack(local_stack), args(args), func(f), alignment(16),
src/IR/eval.cpp:426:      size(f->frame_size), offset(0), inst_ptr(0), curr_block(f->entry()),
src/IR/eval.cpp:428:  stack->AddFrame(this);
src/IR/eval.cpp:430:  // 16-bytes for safety.
src/IR/eval.cpp:436:  used       = MoveForwardToAlignment(used, fr->alignment);
src/IR/eval.cpp:437:  fr->offset = used;
src/IR/eval.cpp:438:  used += fr->size;
src/IR/eval.cpp:449:void LocalStack::RemoveFrame(StackFrame *fr) { used = fr->offset; }
src/IR/eval.cpp:456:  if (frame.inst_ptr == frame.curr_block->cmds.size()) {
src/IR/eval.cpp:458:    frame.curr_block = frame.curr_block->ExecuteJump(frame);
src/IR/eval.cpp:461:      if (frame.prev_block->exit.flag == Exit::Strategy::ReturnVoid) {
src/IR/eval.cpp:464:      } else if (frame.prev_block->exit.val.flag == ValType::Ref) {
src/IR/eval.cpp:465:        return frame.reg[frame.prev_block->exit.val.val.as_ref];
src/IR/eval.cpp:467:      } else if (frame.prev_block->exit.val.flag == ValType::Arg) {
src/IR/eval.cpp:468:        return frame.reg[frame.prev_block->exit.val.val.as_arg];
src/IR/eval.cpp:471:        return frame.prev_block->exit.val;
src/IR/eval.cpp:479:    auto cmd = frame.curr_block->cmds[frame.inst_ptr];
src/Type/Type.cpp:29:    if (array_type->fixed_length) {
src/Type/Type.cpp:31:          array_type->data_type->bytes() * array_type->len, alignment());
src/Type/Type.cpp:39:    for (auto ft : struct_type->field_type) {
src/Type/Type.cpp:40:      num_bytes += ft->bytes();
src/Type/Type.cpp:41:      num_bytes = MoveForwardToAlignment(num_bytes, ft->alignment());
src/Type/Type.cpp:58:    if (array_type->fixed_length) {
src/Type/Type.cpp:59:      return array_type->data_type->alignment();
src/Type/Type.cpp:67:    for (auto ft : struct_type->field_type) {
src/Type/Type.cpp:68:      auto a = ft->alignment();
src/Type/Type.cpp:83:  } else if (lhs_type->is_primitive() || lhs_type->is_pointer() ||
src/Type/Type.cpp:84:             lhs_type->is_enum()) {
src/Type/Type.cpp:87:  } else if (lhs_type->is_struct()) {
src/Type/Type.cpp:88:    builder.CreateCall(static_cast<Structure *>(lhs_type)->assign(),
src/Type/Type.cpp:91:  } else if (lhs_type->is_array()) {
src/Type/Type.cpp:92:    auto assign_fn = static_cast<Array *>(lhs_type)->assign();
src/Type/Type.cpp:93:    assert(rhs_type->is_array());
src/Type/Type.cpp:97:    if (rhs_array_type->fixed_length) {
src/Type/Type.cpp:98:      rhs_len = data::const_uint(rhs_array_type->len);
src/Type/Type.cpp:110:  } else if (lhs_type->is_function()) {
src/Type/Type.cpp:111:    rhs->dump();
src/Type/Type.cpp:112:    lhs_ptr->dump();
src/Type/Type.cpp:129:    if (array_type->data_type->requires_uninit()) {
src/Type/Type.cpp:130:      builder.CreateCall(array_type->destroy(), {var});
src/Type/Type.cpp:132:      if (array_type->fixed_length) {
src/Type/Type.cpp:154:    if (!destroy_fn) { destroy_fn = static_cast<Structure *>(this)->destroy(); }
src/Type/Type.cpp:191:      data_type->is_array() ? 1 + static_cast<Array *>(data_type)->dimension : 1;
src/Type/Type.cpp:195:  has_vars     = data_type->has_vars;
src/Type/Type.cpp:202:  dimension = data_type->is_array()
src/Type/Type.cpp:203:                  ? 1 + static_cast<Array *>(data_type)->dimension
src/Type/Type.cpp:209:  has_vars = data_type->has_vars;
src/Type/Type.cpp:215:    has_vars = entry->has_vars;
src/Type/Type.cpp:219:Pointer::Pointer(Type *t) : pointee(t) { has_vars = pointee->has_vars; }
src/Type/Type.cpp:222:  has_vars = input->has_vars || output->has_vars;
src/Type/Type.cpp:234:  auto num_members = enumlit->members.size();
src/Type/Type.cpp:238:  for (const auto &idstr : enumlit->members) {
src/Type/Type.cpp:249:    enum_str->setAlignment(1);
src/Type/Type.cpp:273:  for (auto opt : options) { has_vars |= opt->has_vars; }
src/Type/Type.cpp:285:                                           : field_type.at(iter->second);
src/Type/Type.cpp:291:  auto num = iter->second;
src/Type/Type.cpp:293:  assert(!t->is_function() && t != Type_ && "Invalid data field");
src/Type/Type.cpp:303:    return iter->second;
src/Type/Type.cpp:314:    if (t->requires_uninit()) return true;
src/Type/Type.cpp:327:  for (auto &kv : ast_expression->cache) {
src/Type/Type.cpp:328:    assert(kv.second->value.as_type);
src/Type/Type.cpp:333:        static_cast<Structure *>(kv.second->value.as_type)->bound_name;
src/Type/Type.cpp:337:        bound_name + str_name.substr(paren_pos, str_name.size() - paren_pos);
src/Type/Type.cpp:358:  // TODO what if ty->alignment() == 0?
src/Type/Type.cpp:361:      last_field_offset + (field_type.empty() ? 0 : field_type.back()->bytes()),
src/Type/Type.cpp:362:      ty->alignment());
src/Type/Type.cpp:379:  if (!ty->is_function() && ty != Type_) {
src/Type/Type.cpp:387:  has_vars |= ty->has_vars;
src/Type/Type.h:272:  RangeType(Type *t) : end_type(t) { has_vars = end_type->has_vars; }
src/Type/Type.h:280:  SliceType(Array *a) : array_type(a) { has_vars = array_type->has_vars; }
src/Type/TypeExterns.cpp:36:  RawPtr->generate_llvm();
src/Type/TypeExterns.cpp:52:  for (auto t : array_types_) t->generate_llvm();
src/Type/TypeExterns.cpp:53:  for (auto t : tuple_types_) t->generate_llvm();
src/Type/TypeExterns.cpp:54:  for (auto t : pointer_types_) t->generate_llvm();
src/Type/TypeExterns.cpp:55:  for (auto t : fn_types_) { t->generate_llvm(); }
src/Type/TypeExterns.cpp:56:  for (auto kv : struct_types_) kv.second->generate_llvm();
src/Type/TypeExterns.cpp:62:    if (arr->fixed_length && arr->len == len && arr->data_type == t) return arr;
src/Type/TypeExterns.cpp:71:    if (!arr->fixed_length && arr->data_type == t) return arr;
src/Type/TypeExterns.cpp:80:    if (tuple_type->entries == types) return tuple_type;
src/Type/TypeExterns.cpp:91:    if (ptr->pointee == t) return ptr;
src/Type/TypeExterns.cpp:101:    if (fn_type->input != in) continue;
src/Type/TypeExterns.cpp:102:    if (fn_type->output != out) continue;
src/Type/TypeExterns.cpp:137:  if (iter != TypeSystem::enum_types_.end()) return iter->second;
src/Type/TypeExterns.cpp:150:  if (iter != TypeSystem::struct_types_.end()) return iter->second;
src/Type/TypeExterns.cpp:158:  t->value = Context::Value(struct_type);
src/Type/TypeExterns.cpp:166:  if (iter != TypeSystem::param_struct_types_.end()) return iter->second;
src/Type/TypeExterns.cpp:181:  if (iter != TypeSystem::vars_.end()) return iter->second;
src/Type/TypeExterns.cpp:193:  if (iter != TypeSystem::ranges_.end()) return iter->second;
src/Type/TypeExterns.cpp:200:  if (iter != TypeSystem::slices_.end())return iter->second;
src/Type/allocate.cpp:18:  if (!fixed_length) { alloc->setName("tmp_array"); }
src/Type/assign.cpp:33:  auto iter    = assign_fn_->args().begin();
src/Type/assign.cpp:37:  len->setName("len");
src/Type/assign.cpp:38:  rhs_ptr->setName("rhs.ptr");
src/Type/assign.cpp:39:  var->setName("var");
src/Type/assign.cpp:54:        builder.CreateMul(len, data::const_uint(data_type->bytes()));
src/Type/assign.cpp:83:  data_type->call_init(to_phi);
src/Type/assign.cpp:90:  from_phi->addIncoming(next_from_ptr, loop_block);
src/Type/assign.cpp:91:  to_phi->addIncoming(next_to_ptr, loop_block);
src/Type/assign.cpp:93:  from_phi->addIncoming(rhs_ptr, entry_block);
src/Type/assign.cpp:94:  to_phi->addIncoming(to_head, entry_block);
src/Type/assign.cpp:119:  auto iter = assign_fn_->args().begin();
src/Type/assign.cpp:128:    if (!the_field_type->is_big()) {
src/Type/assign.cpp:134:    Type::CallAssignment(ast_expression->scope_, the_field_type, the_field_type,
src/Type/generate_llvm.cpp:14:    data_type->generate_llvm();
src/Type/generate_llvm.cpp:16:    auto struct_type = llvm::StructType::create(global_module->getContext());
src/Type/generate_llvm.cpp:18:    struct_type->setBody({*Uint, *Ptr(data_type)}, /* isPacked = */ false);
src/Type/generate_llvm.cpp:19:    struct_type->setName(Mangle(this));
src/Type/generate_llvm.cpp:26:  pointee->generate_llvm();
src/Type/generate_llvm.cpp:27:  llvm_type = llvm::PointerType::getUnqual(pointee->llvm_type);
src/Type/generate_llvm.cpp:31:  if (t->is_pointer()) {
src/Type/generate_llvm.cpp:36:  if (t == Void || t == Type_ || t->has_vars) { return; }
src/Type/generate_llvm.cpp:37:  assert(t->llvm_type);
src/Type/generate_llvm.cpp:39:  if (t->is_primitive() || t->is_enum()) {
src/Type/generate_llvm.cpp:42:  } else if (t->is_big()) {
src/Type/generate_llvm.cpp:53:  input->generate_llvm();
src/Type/generate_llvm.cpp:54:  output->generate_llvm();
src/Type/generate_llvm.cpp:58:  if (input->is_tuple()) {
src/Type/generate_llvm.cpp:60:    for (auto t : in_tup->entries) { AddLLVMInput(t, llvm_in); }
src/Type/generate_llvm.cpp:66:  if (!output->is_big()) {
src/Type/generate_llvm.cpp:72:  } else if (output->is_tuple()) {
src/Type/generate_llvm.cpp:74:    for (auto t : out_tup->entries) { AddLLVMInput(Ptr(t), llvm_in); }
src/Type/generate_llvm.cpp:76:  } else if (output->is_function()) {
src/Type/generate_llvm.cpp:88:  for (auto t : entries) t->generate_llvm();
src/Type/generate_llvm.cpp:94:  auto struct_type = llvm::StructType::create(global_module->getContext());
src/Type/generate_llvm.cpp:97:  for (const auto &f : field_type) f->generate_llvm();
src/Type/generate_llvm.cpp:102:    llvm_fields[kv.second] = field_type AT(kv.first)->llvm_type;
src/Type/generate_llvm.cpp:106:      ->setBody(std::move(llvm_fields), /* isPacked = */ false);
src/Type/generate_llvm.cpp:108:  struct_type->setName(bound_name);
src/Type/initial_value.cpp:31:    auto init_elem = data_type->InitialValue();
src/Type/initialize.cpp:54:    auto arg = init_fn_->args().begin();
src/Type/initialize.cpp:63:        data_type->call_init(
src/Type/initialize.cpp:118:      if (init_expr && init_expr->is_hole()) { continue; }
src/Type/initialize.cpp:122:          builder.CreateGEP(init_fn_->args().begin(),
src/Type/initialize.cpp:125:        auto init_val = init_expr->generate_code();
src/Type/initialize.cpp:127:        Type::CallAssignment(ast_expression->scope_, the_field_type,
src/Type/initialize.cpp:130:        the_field_type->call_init(arg);
src/Type/initialize.cpp:141:// TODO rename? This isn't really about init-ing literals. it's more about allocating
src/Type/initialize.cpp:143:  auto use_calloc         = data_type->is_primitive();
src/Type/initialize.cpp:149:                           {len, data::const_uint(data_type->bytes())}),
src/Type/initialize.cpp:154:        builder.CreateMul(len, data::const_uint(data_type->bytes()));
src/Type/initialize.cpp:196:    IR::Block::Current = init_func->entry();
src/Type/initialize.cpp:201:        IR::Block::Current->push(gep);
src/Type/initialize.cpp:202:        data_type->EmitInit(gep);
src/Type/initialize.cpp:215:  IR::Block::Current->cmds.push_back(call);
src/Type/initialize.cpp:229:    IR::Block::Current = init_func->entry();
src/Type/initialize.cpp:234:      IR::Block::Current->push(gep);
src/Type/initialize.cpp:235:      field_type[i]->EmitInit(gep);
src/Type/initialize.cpp:245:  IR::Block::Current->cmds.push_back(call);
src/Type/repr.cpp:27:  switch_stmt->addCase(data::const_char(char_to_display), branch);
src/Type/repr.cpp:46:      llvm::Value *arg = repr_fn_->args().begin();
src/Type/repr.cpp:98:                        data::global_string(type_val->to_string())});
src/Type/repr.cpp:113:    llvm::Value *arg = repr_fn_->args().begin();
src/Type/repr.cpp:123:        data_type->call_repr(PtrCallFix(data_type, start_ptr));
src/Type/repr.cpp:130:        data_type->call_repr(PtrCallFix(data_type, ptr));
src/Type/repr.cpp:155:      data_type->call_repr(PtrCallFix(data_type, start_ptr));
src/Type/repr.cpp:165:      phi->addIncoming(start_ptr, loop_head_block);
src/Type/repr.cpp:171:      data_type->call_repr(PtrCallFix(data_type, phi));
src/Type/repr.cpp:176:      phi->addIncoming(next_ptr, loop_block);
src/Type/to_string.cpp:29:    ss << "--";
src/Type/to_string.cpp:33:  while ((*type_ptr_ptr)->is_array()) {
src/Type/to_string.cpp:36:    if (array_ptr->fixed_length) {
src/Type/to_string.cpp:37:      ss << array_ptr->len;
src/Type/to_string.cpp:39:      ss << "--";
src/Type/to_string.cpp:42:    type_ptr_ptr = &array_ptr->data_type;
src/Type/to_string.cpp:51:  if (input->is_function()) {
src/Type/to_string.cpp:58:  ss << " -> " << *output;
src/Type/to_string.cpp:64:  if (pointee->is_function()) {
src/Type/to_string.cpp:87:std::string TypeVariable::to_string() const { return identifier->token; }
src/Type/to_string.cpp:97:  return "Range(" + end_type->to_string() + ")";
src/Type/to_string.cpp:100:  return array_type->to_string() + "[..]";
src/Type/type_time.cpp:7:  // so we can use the casts bool -> int -> Time::eval
src/Type/type_time.cpp:11:Time::Eval Array::time() const { return data_type->time(); }
src/Type/type_time.cpp:12:Time::Eval Function::time() const { return input->time() | output->time(); }
src/Type/type_time.cpp:13:Time::Eval Pointer::time() const { return pointee->time(); }
src/Type/type_time.cpp:17:  for (auto t : entries) { output |= t->time(); }
src/Type/type_time.cpp:27:Time::Eval RangeType::time() const { return end_type->time(); }
src/Type/type_time.cpp:28:Time::Eval SliceType::time() const { return array_type->time(); }
src/Type/type_time.cpp:34:  for (auto opt : options) { time |= opt->time(); }
src/Type/uninitialize.cpp:31:  auto array = destroy_fn_->args().begin();
src/Type/uninitialize.cpp:32:  array->setName("array");
src/Type/uninitialize.cpp:52:    phi->addIncoming(data_ptr, entry_block);
src/Type/uninitialize.cpp:58:    data_type->CallDestroy(nullptr, phi);
src/Type/uninitialize.cpp:62:    phi->addIncoming(next_ptr, loop_block);
src/Type/uninitialize.cpp:86:    auto val_to_destr   = destroy_fn_->args().begin();
src/Type/uninitialize.cpp:88:    if (the_field_type->requires_uninit()) {
src/Type/uninitialize.cpp:91:      the_field_type->CallDestroy(nullptr, arg);
src/config/operator.conf:16:OPERATOR_MACRO( Arrow,          ->,       7,  right_assoc )
src/config/operator.conf:21:OPERATOR_MACRO( SubEq,          -=,      11,    non_assoc )
src/config/operator.conf:36:OPERATOR_MACRO( Sub,            -,       18,   left_assoc )
